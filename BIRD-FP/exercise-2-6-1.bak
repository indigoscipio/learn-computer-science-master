#lang racket

;richard bird functional programming book exercise
;2.5.1
; define versions of functions A and V using patterns for the second arguent
; edfine which use patterns for both arguments.
; draw up a table showing the values of and and or for each version

; x A True -> x
; x A False -> false
; x V true -> true
; x v False -> x

#|
; Boolean Boolean -> Boolean
(define (my-and a b)
  (cond [b a]
        [else #f])
  )

; Boolean BOolean -> Boolean
(define (my-or a b)
  (cond [b #t]
        [else a])
  )
|#


; =======================
; versions which use both arguments

; AND
; True A True -> T
; True A False -> F
; False A True -> F
; False A False -> F

; OR
; True V True -> T
; True V False -> T
; False V Tree -> T
; False V False -> F

(define (my-and a b)
  #|
  (cond [(and (equal? a #t) (equal? b #t)) #t]
        [(and (equal? a #t) (eq? b #f)) #f]
        [(and (equal? b #t) (eq? a #f)) #f]
        [else #f]
        )
  |#

  (if (or (eq? a #f) (eq? b #f))
      #f
      #t
      )
  )


(define (my-or a b)
  (if (and (eq? a #f) (eq? b #f))
      #f
      #t
      )
  )



;2.5.2
; is the definition of pred given in the text equivalent to the following one?
; pred n = 0 if n = 0
;        = n-1 if n > 0

; answer: ok so this looks like if the input is 0, return 0
; if the input is positive integer, return n-1/the previous number
; not sure what it wants me todo

; let n = 3
; is it 0? no -> 3-1 = 2

; since we know k = n+1
; we can subtitute n
; k = (n-1) + 1
; k = n

(define (three n ) 3)

(three 1/0)