Data types

integers -> exact
fractions -> floating point approximation

what is floating point?
a way for computer to approximate decimal
similar to scientific notation

==========

infix -> standard notation,
opration sits between arguments, eg (3 + 5)

prefix
operation sits before argument, like racket (+ 3 5)

=============

precedence / order of operation
PEMDAS

association
3 - 7 - 2 - how to evaluate it?
left to right
(3 - 7) - 2

===============

 in fp, function application is treated with the highest priority

 Precedence - stickiness hierarchy
 - function application
 - exponentiation
 - mult/div
 - add/sub

 Order of association
 left-associative
group left to right
most of arithmetic does this

 right-associative
 group right to left
 exponentiation does this


 ======

 operators and sections
 (+) - this is a section
 enclosing operator converts to a prefix function

 (+) x y -> x + y

 both f x = f x x
 both (*) 5 = (*) 5 5 = 25


 ====

 computing sqrt of a number using approximation
 sqrt is defined as

 sqrt x >= 0 and sqrt(x)^2 = x

 here we define it as
 sqrt x >= 0 and abs(sqrt(x)^2 - x) < eps

 newton's method
 yn+1 = (yn + x / yn) / 2
 y = approximation
 yn = current guess
 yn + 1 = next guess
 x = target number - value stays the same - number that you want the square root of

 why -x ? to see hwo far the error/distance between landing spot vs target

 example:
 x = 9 - we wanna find the sqrt of 9
 suppose y0 (initial guess) = 1
 find the next guess
 yn+1 = 1 + 9 /1 / 2
 y1 = 10 / 2 = 5 -> is 5^2 close to 9? no, 25-9 = 16. still too far
 
 keep guessing, find y2
y2 = 5 + 9/5 / 2 = 3.4

keep guessing
y3 = 3.4 + 9 / 3.4 / 2 = 3.4 + 2.6 / 2 = ~3...


improve x y = (y + x/y) / 2 - the averaging machine
satis x y = abs(y^2 - x) < eps - the stopping condigion

until p f x = x - the loop
            = until p f (f x) otherwise
where p = the stopping condiiton checker
f = the averaging machine
x = the target number of sqrt we wanna find

until: (a -> bool) -> (a -> a) -> a -> a

Exercises

2.1.1
the oeprators x and div have the same binding power and associate to the left
what is the value of the following expr?

1. 3 div 1 x 3
2. 3 x 7 div 4
3. 6 div 2 x 8 div 4

answer:
1. 3 x 3 = 9
2. 21 div 4 = 5
3. 6 div 2 = 3
3 x 8 div 4
24 div 4 = 6

2.1.2
using the definition of mod given in 2.1.3
show that for all positive x,y, and z

definition from 2.1.3
x = q * y + r and 0 <= r < y
where q = quotient
r = reminder
y = divisor

1. (x + y) mod z = (x mod z + y mod z) mod z
2. x * (y mod z) = (x * y) mod (x * z)

answer:
LHS
(x + y) mod z

x = q1 * z + r1
y = q2 * z + r2

= (q1 * z + r1) + (q2 * z + r2)
= q1 * z + q2 * z + r1 + r2
= z (q1 + q2) + r1 + r2
since q1 + q2 is a multiple of z, it has no reminder
mod z in the first part is 0
= r1 + r2 mod z
(x mod z) + (y mod z) mod z

part 2
x * (y mod z) = (x + y) mod (x * z)

LHS
y = q * z + r where
r = y mod z

x * y = x (qz + r)
xy =  xqz + xr 

we wanna find the remainder of (x+y) when divided when divisor (x * z)
rearrange
xy = q(xz) + xr
xy mod xz = xr
xy mod xz = x . (y mod z)

2.1.4
what function is (+ (-x))
answer:

lets see,
first it negate x
then it adds that with an empty argument? not sure

so in cases x is negative
-x -> negate = positive -> adds with empty args - positive
x -> negate = negative -> adds with empty args - negative

so its like a sign inverter?

2.15
for what arguments do the following functions return true?
(= 9) . (2 +) . (7x) . (3 >) . (mod 2)

1. 9
2. 7
3. multiply funcion doest return a boolean
4. any numbers less than 3
5. any number that doesnt have atruthy value like 0?

2.16
which of the following statements are true (if any?)
(x) x = (x x)
(+) x = (x +)
(-) x = (-x)
answer:
not sure what this means here,
1. were applying the operation multiply to argument x - does it always equal x?
yes since multiplication is commutative
2. were applying the addition operation to argument x - does it equal x +?
yes since addition is commutative  doesnt matter where you add
3. were applying the operation - to argument x, does it equal (-x)?
no, one is a function and another is a number

2.1.7
in newtons method the test for determining wheter an approximation
y to sqrt x is good enough was defined to be

abs(y^2 - x) < eps

another test is
abs(y^2 - x) < eps * x

rewrite the sqrt function to use this test
answer:


sqrt x >= 0 and abs(y^2 - x) < eps * x

yet another test for convergence is to stop when two successive approximation y and y' are
sufficiently close

sqrt x = until goodEnough improve x
  where
    goodEnough y = abs (y^2 - x) < eps * x
    improve y = (y + x/y) / 2
    eps = 0.0001



========================


BOoleans
Polymorphic comparison
a -> a -> Bool
2 = 3
False < true
2 = true (type error)

Comparison operators have the same level of precedence
>, <, =<, etc


======================

Bottom symbol
it never halts


=================

Characters
Code -> char to ascii
decode -> ascii ot char
these are two essential helpers