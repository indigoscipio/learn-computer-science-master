Referrential Transparency
An expression can be replaced by its value without changing the program’s meaning.


how fp works
- sees an expression
- substitute that expression using definition (the RULE)
- simplify that expression using the defintion
- keep evaluating until you see no value that can be evaluated
- that value ist he final value

building definitionw
what is a definition?
A definition is how the program “knows” what a name means.
it is a set of rule that govern how the program behaves
definition are always algebraic in nature

eg. square x = x . x
min x y = if x < y return x else return y

canonical expression = expression that cannot be simplified further
aka normal form

referrential transparency
equal expression can be repalced with each other anywhere
(+ 3 4) -> can be replaced with 7

value does not equal representaiton of a value
49 = 7 x 7 = XLIX = 110001
FP is about value, not representation of a value

order of value does not matter
because epression always evaluate to the same value
no matter how you reduce them

=====================


1.4 Functions and definitions

func x = "A" (char)
func y = func x + y -> this is illegal

2 stage of analysis
1. syntax analysis: check expression
2. type analysis : matches differen type

evaluation only begins when it passes these 2 stages


functions
f :: A -> B
where a is the source/input type and b is the targe/totput type

the function f
functions are values

function value vs function definitino

double x = x + x
double' x = 2 * x

one can be more efficient than the other,
but efficiency cannot be attached to function values

Polymorphisn

square :: num -> num -> type declaration
square x = x * x  -> function definition

type variable:
greek alphabet a -> a

identity function is polymorphic
constant function

------

forms of definition

======================

Currying
break down multi arg function -> single arg function

min x y
if x <= y return x
if x > y return y

min' (x, y)
if x <= y return x, else return y

type
min = num num -> num
min' (num, num) -> num

partial application
from multiple argument > less arguments
it remembers the arguments
decrease the arguments
we can parameterize without rewriting new logic

currying
min x y = ((min x) y)

function composition
is all about chaining the functions
not adding their result


Exercises

1.41
describe one appropriate type for the definite integral function of
mathematical analysis as usedi n the phrase the integral from a to b

2. 
takes 3 inputs
function to be integrated (number -> number)
upper limit a
lower limit b

integral(f, a, b)
(num -> num) -> num -> num -> num

1.4.2
give examples of functions with the following types
(num -> num) -> num
num -> (num -> num)
(num -> num) -> (num -> num)

answer:
(num -> num) -> num
(HOF Style pattern)
function that takes a function and returns a number
fn x = x * x
at_zero f = (f 0)

RACKET EXAMPLE:

num -> (num -> num)
function creator
add n x = x + n
where n is the recipe
and x is the argument

example:
add 10 x -> x + 10 
(add 10) 5 -> 15

RACKET EXAMPLE:

(num -> num) -> (num -> num)
function transformer
double_result f x = 2 * f(x)
twice f x = f(f(x))

1.4.3
give a definition of a function
sign:: num -> number which returns 1 if its argument is positievv
-1 if its argument is negative,
and 0 otherwise

1.4.4
suggest possible types for the following functions

1. one x = 1
2. apply f x = f x
3. compose f g x = f(g x)

answer:
1. the function one takes x and returns a number 1, so
(any -> number)

2. function apply takes function f -> then number y,
then returns application of that function to x
like hof?
so (A -> B) -> A -> B

3. this is function composition where it chains multiple functions
(B -> C) -> (A -> B) -> A -> C

(A -> B) -> (B -> C)  -> A -> C


==================

specification vs implementation
specificaton = the what
purpose, clarity

implementation = the how
efficiency

=============

exercise 1.5.1

write down specification of function isSquare
that determines wheter or not its argumennt is an integer which is the square of another integer

suppose (intsqrt x) is the largest integer which is no greater than sqrt(x)
will the following efinition meet your specification?

isSquare x = (square (intsqrt x) = x )

answer:
specification:
is-square? x
is-square? num -> bool
input : x needs to be a non negative number?
output: a boolean, if true then x is the square of another integer, if false then its not
that is n^2 = x

isSquare x = (square (intsqrt x) = x )
if x is negative then intsqrt is imaginary?
setup a conditional and check for x
if x is negative, return error

1.5.2
write down a precise specification of the function intsqrt mentioned in the previous question
;; intsqrt: number -> number
takes a number x, returns r - the largest integer no greater than sqrt(x)
- x and r must be an integer
- r <= sqrt(x)
- next integer (r + 1)^2 must be > x