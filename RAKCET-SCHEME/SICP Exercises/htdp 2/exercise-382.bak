;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname exercise-382) (read-case-sensitive #t) (teachpacks ((lib "convert.rkt" "teachpack" "htdp") (lib "image.rkt" "teachpack" "2htdp") (lib "universe.rkt" "teachpack" "2htdp") (lib "batch-io.rkt" "teachpack" "2htdp") (lib "web-io.rkt" "teachpack" "2htdp") (lib "abstraction.rkt" "teachpack" "2htdp") (lib "dir.rkt" "teachpack" "htdp"))) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ((lib "convert.rkt" "teachpack" "htdp") (lib "image.rkt" "teachpack" "2htdp") (lib "universe.rkt" "teachpack" "2htdp") (lib "batch-io.rkt" "teachpack" "2htdp") (lib "web-io.rkt" "teachpack" "2htdp") (lib "abstraction.rkt" "teachpack" "2htdp") (lib "dir.rkt" "teachpack" "htdp")) #f)))
; An FSM is a [List-of 1Transition]
; A 1Transition is a list of three items:
;   (cons FSM-State (cons String (cons FSM-State '())))
; - The first FSM-State is the **current state**.
; - The String is the **allowed key event** for the transition.
; - The second FSM-State is the **next state**.


 
; data examples 
(define fsm-traffic
  '(("red" "g" "green") ("green" "y" "yellow") ("yellow" "r" "red")))

 
; [X Y] [List-of [List X Y]] X -> Y
; finds the matching Y for the given X in alist
(define (find alist x)
  (local ((define fm (assoc x alist)))
    (if (cons? fm) (rest fm) (error "not found"))))

 

; FSM-State FSM -> FSM-State 
; matches the keys pressed by a player with the given FSM
(define (simulate state0 transitions)
  (big-bang state0 ; FSM-State
    [to-draw
      (lambda (current)
        (overlay (text current 24 "black")
                 (square 100 "solid" current) ))]
    [on-key
     (lambda (current key-event)
       (local ((define transition (find transitions current) ))
         (if (key=? key-event (first transition))
             (second transition)
             current
             )
         )
        )]))
;(simulate "red" fsm-traffic)


;Exercise 381. The definitions of XMachine and X1T use quote
;which is highly inappropriate for novice program designers.
;Rewrite them first to use list and then cons.

; Rewritten versionx
; An XMachine is a nested list of this shape:
; (list 'machine (('initial FSM-state)) [List-of-X1T])
; (cons 'machine (cons (list 'initial FSM-state) [List-of-X1T]))

; An X1T is a nested list of this shape:
; (list 'action (('state FSM-State) ('next FSM-State)))
; (cons 'action (cons (list (list 'state FSM-state) (list 'next FSM-state)) '() ))

;Exercise 382. Formulate an XML configuration for the BW machine,
;which switches from white to black and back for every key event.
;Translate the XML configuration into an XMachine representation.
;See exercise 227 for an implementation of the machine as a program.

; a BW machine configuration
(define xm0
  '(machine ((initial "red"))
     (action ((state "red") (next "green")))
     (action ((state "green") (next "yellow")))
     (action ((state "yellow") (next "red")))))


(define (xm-state0 xm)
  (second (first (first (rest xm))))
  )
(check-expect (xm-state0 xm0) "red")

(define (xm->transitions xm0)
  )
(check-expect (xm->transitions xm0) fsm-traffic)

