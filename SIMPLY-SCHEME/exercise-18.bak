#lang simply-scheme

(append '(2 3) '((2 3) () 4 5))

; use list only when you know how many leements are there in your complete list



#|
17.1 What will Scheme print in response to each of the following expressions?
Try to figure it out in your head before 
you try it on the computer.
(car '(Rod Chris Colin Hugh Paul))
(cadr '(Rod Chris Colin Hugh Paul))
(cdr '(Rod Chris Colin Hugh Paul))
(car 'Rod)
(cons '(Rod Argent) '(Chris White))
(append '(Rod Argent) '(Chris White))
(list '(Rod Argent) '(Chris White))
(caadr '((Rod Argent) (Chris White)
           (Colin Blunstone) (Hugh Grundy) (Paul Atkinson)))
(assoc 'Colin '((Rod Argent) (Chris White)
                  (Colin Blunstone) (Hugh Grundy) (Paul Atkinson)))
(assoc 'Argent '((Rod Argent) (Chris White)
                   (Colin Blunstone) (Hugh Grundy) (Paul Atkinson)))

answer:
(car '(Rod Chris Colin Hugh Paul)) ; rod
(cadr '(Rod Chris Colin Hugh Paul)) ;chris
(cdr '(Rod Chris Colin Hugh Paul)) ;'(chris colin uhgh paul)
; (car 'Rod) ; error not a list
(cons '(Rod Argent) '(Chris White)) ; ((rod argent) christ white)
(append '(Rod Argent) '(Chris White)) ;(rod argent chris whtie)
(list '(Rod Argent) '(Chris White)) ;'((rod argent)(chris white))
(caadr '((Rod Argent) (Chris White)(Colin Blunstone) (Hugh Grundy) (Paul Atkinson))) ;chris
(assoc 'Colin '((Rod Argent) (Chris White) (Colin Blunstone) (Hugh Grundy) (Paul Atkinson))) ;colin bluntstone
(assoc 'Argent '((Rod Argent) (Chris White) (Colin Blunstone) (Hugh Grundy) (Paul Atkinson))) ;#f
|#

; =======================================

#|
17.2 For each of the following examples, write a procedure of two arguments that, when applied to the sample 
arguments, returns the sample result. Your procedures may not include any quoted data.
Page 300
> (f1 '(a b c) '(d e f))
((B C D))
> (f2 '(a b c) '(d e f))
((B C) E)
> (f3 '(a b c) '(d e f))
(A B C A B C)
> (f4 '(a b c) '(d e f))
((A D) (B C E F))
|#
(define (f1 se1 se2)
  (list (list (cadr se1) (last se1) (car se2)))
  )
(f1 '(a b c) '(d e f))

(define (f2 se1 se2)
  (list (cdr se1) (cadr se2))
  )
(f2 '(a b c) '(d e f))

(define (f3 se1 se2)
  (append se1 se1)
  )
(f3 '(a b c) '(d e f))

(define (f4 se1 se2)
  (list (list (car se1) (car se2)) (append (cdr se1) (cdr se2)))
  )
(f4 '(a b c) '(d e f))

; =======================================

#|
17.3 Describe the value returned by this invocation of map:
> (map (lambda (x) (lambda (y) (+ x y))) '(1 2 3 4))
|#

((car (map (lambda (x) (lambda (y) (+ x y))) '(1 2 3 4))) 10)
; binds x = 1, then inside return another function that waits for another number
; so it seems like adding function that waits for y? 
; returns a list function that awais for argument y and adds that with x


; =======================================

; REAL EXERCISE

#|
17.4 Describe the result of calling the following procedure with a list as its argument.
(See if you can figure it out before you try it.)

(define (mystery lst)
  (mystery–helper lst '()))

(define (mystery–helper lst other)
  (if (null? lst)
      other
      (mystery–helper (cdr lst) (cons (car lst) other))))

answer:
its a list rebuilding function where mysery helper
it other stores the accumulated list/result in reversed order
everytime mystery helper runs it stores the first item in the list into tother
and recurse with decreased list

|#


; =============================================

#|
17.5 Here's a procedure that takes two numbers as arguments and returns whichever number is larger:

(define (max2 a b)
  (if (> b a) b a))

Use max2 to implement max, a procedure that takes one or more
numeric arguments and returns the largest of them
|#
(define (max2 a b)
  (if (> b a) b a))

(define (my-max fst-arg . rest-args)
  (cond [(empty? rest-args) fst-arg]
        [else (apply my-max (cons (max2 fst-arg (car rest-args)) (cdr rest-args)))]
        )
  )
(my-max 1 2 3 8 7 -55 11)

; ===================================================

#|
17.6 Implement append using car, cdr, and cons.
(Note: The built-in append can take any number of arguments.
First write a version that accepts only two arguments.
Then, optionally, try to write a version that takes any number.)
|#

(define (append-car se1 se2)
  ; recurse through se1, store result inse 2
  (cond [(empty? se1) se2]
        [(empty? se2) se1]
        [else (cons (car se1) (append-car (cdr se1) se2))]
        )
  )
(append-car '() '(a b c)) ;'(a b c)
(append-car '(a b c) '()) ;'(a b c)
(append-car '(a b c) '(d e f)) ;'(a b c d e f)

(define (append-car-anyargs . args)
  (cond [(empty? args) '()]
        [(empty? (cdr args)) (car args)] ;one item left, just return that item
        [else (let ((fst (car args))
                    (sec (cadr args))
                    (rest (cddr args))
                    )
                (apply append-car-anyargs (cons (append-car fst sec) rest))
                ) ]
        )
  )
(append-car-anyargs '() '(a b c)) ;'(a b c)
(append-car-anyargs '() '()) ;'()
(append-car-anyargs '()) ;'()
(append-car-anyargs '(a b) '(d e) '(g h)); '(a b c d e f g)


#|
17.7 Append may remind you of sentence. They're similar, except that append works only with lists as 
arguments, whereas sentence will accept words as well as lists. Implement sentence using append.
(Note: The built-in sentence can take any number of arguments. First write a version that accepts
only two arguments. Then, optionally, try to write a version that takes any number.
Also, you don't have to worry about the error checking that the real sentence does.)
|#

; word/list word/list -> list-of-x
(define (my-sentence xs ys)
  (let ((list-x (if (list? xs) xs (list xs)))
        (list-y (if (list? ys) ys (list ys))))
    (append-car list-x list-y)))
(my-sentence '(c) '(a b))
(my-sentence 'a 'bc)

(define (my-sentence-anyargs . args)
  (let ((normalized (map (λ (arg) (if (list? arg)
                                      arg
                                      (list arg)
                                      )) args)))
    (apply append-car-anyargs normalized)
    )
  )
(my-sentence-anyargs '(a b) '(b c) '(c d)) ;'(a b c)
(my-sentence-anyargs 'hey 'there 'folks) ;'heytherefolks

#|
17.8 write member
|#

(define (my-member x xs)
  (cond [(empty? xs) #f]; not found, return false
        [(equal? x (car xs)) xs] ;return the rest of the list
        [else (my-member x (cdr xs))]
        )
  )
(my-member 'a '(b a c d))
(my-member 'x '(a b c)) ;return #f
(my-member 'a '(b c d e a)) ; return '(a)
(my-member 'hey '(hey you there)) ; return '(hey you there)



; ===========================================================

#|
17.9
write list-ref
|#

; assume i is nonnegative to make this simpler
; and xs is nonempty
(define (my-list-ref xs i)
  ;if index > list length, return error
  ; otherwise keep finding
  ; handle error
  (cond  [(empty? xs) (error "Index out of bounds")]
         [(zero? i) (car xs)]
         [else (my-list-ref (cdr xs) (- i 1))]
         )
  )
(my-list-ref '(0 1 2 3 4) 0) ;0
(my-list-ref '(a b c) 2) ;c

; ===========================================================

#|
17.10
write length
|#

(define (my-length xs)
  (cond [(empty? xs) 0]
        [else (+ 1 (my-length (cdr xs)))])
  )
(my-length '()) ;0
(my-length '(a b c d)) ;4
(my-length '(1 2 3)) ;3

; ===========================================================

#|
17.11 Write before–in–list?, which takes a list and two elements of the list. It should return #t if the second 
argument appears in the list argument before the third argument:
> (before–in–list? '(back in the ussr) 'in 'ussr)
#T
> (before–in–list? '(back in the ussr) 'the 'back)
#F
The procedure should also return #f if either of the supposed elements doesn't appear at all.
|#

(define (before-in-list? xs a b)
  (cond [(empty? xs) #f]
        [(equal? (first xs) a) (member? b (cdr xs))]
        [else (before-in-list? (cdr xs) a b)]
        )
  )
(before-in-list? '(back in the ussr) 'in 'ussr)
(before-in-list? '(back in the ussr) 'the 'back)

; ===========================================================

#|
17.12 Write a procedure called flatten that takes as its argument a list, possibly including sublists, but whose 
ultimate building blocks are words (not Booleans or procedures). It should return a sentence containing all the words 
of the list, in the order in which they appear in the original:
> (flatten '(((a b) c (d e)) (f g) ((((h))) (i j) k)))
(A B C D E F G H I J K)
|#

(define (flatten xxs)
  (cond [(empty? xxs) '()] ;input are empty, just return it
        [(word? (car xxs)) (cons (car xxs) (flatten (cdr xxs)))] ;xxs is already word, just put in front and  recurse
        [else (append (flatten (car xxs))
                      (flatten (cdr xxs))
                      ) ] ;not words
        )
  )
(flatten '(a))
(flatten '(() ())) ;'()
(flatten '((a) b)) ; '(a b)
(flatten '(a b c)) ;already flattened
(flatten '(((a b) c (d e)) (f g) ((((h))) (i j) k)))


; ===========================================================

#|
7.13 Here is a procedure that counts the number of words anywhere within a structured list:
(define (deep–count lst)
  (cond ((null? lst) 0)
        ((word? (car lst)) (+ 1 (deep–count (cdr lst))))
        (else (+ (deep–count (car lst))
                 (deep–count (cdr lst))))))
Although this procedure works, it's more complicated than necessary. Simplify it
|#

(define (deep-count lst)
  (cond ((empty? lst) 0)
        ((word? lst) 1)
        (else (+ (deep-count (car lst))
                 (deep-count (cdr lst))))))
(deep-count '(a b (c d (e f))))

; =============================================================

#|
17.14 Write a procedure branch that takes as arguments a list of numbers and a nested list structure. It should be the 
list-of-lists equivalent of item, like this:
> (branch '(3) '((a b) (c d) (e f) (g h)))
(E F)
> (branch '(3 2) '((a b) (c d) (e f) (g h)))
F
> (branch '(2 3 1 2) '((a b) ((c d) (e f) ((g h) (i j)) k) (l m)))
H
In the last example above, the second element of the list is
((C D) (E F) ((G H) (I J)) K)
The third element of that smaller list is ((G H) (I J)); the first element of that is (G H); and the second element 
of that is just H
|#

(define (branch xs xxs)
  ; case: xs is 1 item

  ;case: xs is more than 1 item,
  ; do case 1, then move on to the next case

  ; case: xxs is empty
  ; nothing to get (or possibly error?)

  ; case: xs is empty:
  ; just return xxs
  (cond [(empty? xs) xxs]
        [else (branch (cdr xs) (item (car xs) xxs) )]
        )
  )
(branch '(1) '(a b c)) ;reutrn 1st item
(branch '(3) '((a b) (c d) (e f) (g h))) ;return 3rd item
(branch '(3 2) '((a b) (c d) (e f) (g h)))
(branch '(2 3 1 2) '((a b) ((c d) (e f) ((g h) (i j)) k) (l m)))

#|
17.16 Write a predicate valid–infix? that takes a list as argument and returns #t if and only if the list is a 
legitimate infix arithmetic expression (alternating operands and operators, with parentheses—that is, sublists—allowed 
for grouping).
> (valid–infix? '(4 + 3 * (5 – 2)))
#T
> (valid–infix? '(4 + 3 * (5 2)))
#F
|#

; checks if an item is an operand
(define (is-operand? x)
  (cond [(number? x) #t]
        [(list? x) (valid-infix? x)] ;its a subexpression
        [else #f]
        )
  )

; checks if x is an operator
(define (is-operator? x)
  (member? x '(* / - +))
  )

; list-of-x symbol -> boolean
(define (check-infix remaining-list expected-type)
  (cond [(empty? remaining-list) (and (empty? remaining-list)
                                      (equal? expected-type 'operator)
                                      )] ;we've checked everything
        [(equal? expected-type 'operand) (if (is-operand? (car remaining-list))
                                             (check-infix (cdr remaining-list) 'operator)
                                             #f
                                             )] ;expected-type is an operand
        [else (if (is-operator? (car remaining-list))
                  (check-infix (cdr remaining-list) 'operand)
                  #f
                  )]
        )
  )
(check-infix '(1 +) 'operand)

(define (valid-infix? expr)
  (check-infix expr 'operand)
  )
(valid-infix? '(3)) ;false
(valid-infix? '(3 +)) ;false
(valid-infix? '(4 + 3 * (5 - 2))) ;#t
(valid-infix? '(4 + 3 * (5 2))) #;f