#lang simply-scheme

#|
(define (get-fn)
  (display "Functions: ")
  (read)
  )
|#


(define NUM-WORDS '("First" "Second" "Third" "Fourth" "Fifth"))
; lets keep it simple only up to 5 args max for now
; assume n is positive int
(define (num->wd n)
  (item n NUM-WORDS)
  )

(define (get-arg n t)
  (if (= t 1)
      (begin  (display "Argument: ")
              (read))
      (begin (display (word (num->wd (+ (- t n) 1)) " Argument") )
             (read)
             )
      )
  )

(define (get-args n t)
  (if (= n 0)
      '()
      (let ((first (get-arg n t)))
        (cons first (get-args (- n 1) t))))
  )
(get-args 3 3)


(define (show-answer answer)
  (newline)
  (display "The result is: ")
  (if (not answer)
      (show "#F")
      (show answer))
  (newline))
(show-answer "")


; ============================

(define (two–numbers? x y)
  (and (number? x) (number? y)))

; FUNCTIONs
(define *the–functions*     ;; partial listing
  (list (list '* * 2 (lambda (x y) (and (number? x) (number? y))) "both args must be number")
        (list '+ + 2 (lambda (x y) (and (number? x) (number? y))) "both args must be number")
        (list 'and (lambda (x y) (and x y)) 2
              (lambda (x y) (and (boolean? x) (boolean? y))) "both args must be boolean")
        (list 'equal? equal? 2 (lambda (x y) #t))
        (list 'even? even? 1 integer?)
        (list 'word word 2 (lambda (x y) (and (word? x) (word? y))))
        )
  )

#|
(define (scheme–procedure fn–name)
  (cadr (assoc fn–name *the–functions*)))
(define (arg–count fn–name)
  (caddr (assoc fn–name *the–functions*)))
(define (type–predicate fn–name)
  (cadddr (assoc fn–name *the–functions*)))
|#

(define (in–domain? args fn–name)
  (apply (type–predicate fn–name) args))


; =============================================

#|
21.1 The get–args procedure has a let that creates the variable first, and then that variable is used only once 
inside the body of the let. Why doesn't it just say the following?
(define (get–args n)
  (if (= n 0)
      '()
      (cons (get–arg) (get–args (– n 1)))))

answer:
cos of the order of evaluation, the evaluator doesn't know which one to do first
(get arg) or recurse first
by using let we force the evaluator to finish get arg first then save that result.

|#

; =============================================

#|
21.2 The domain-checking function for equal? is
(lambda (x y) #t)
This seems silly; it's a function of two arguments that ignores both arguments and always returns #t. Since we know 
ahead of time that the answer is #t, why won't it work to have equal?'s entry in the a-list be
(list 'equal? equal? 2 #t)

answer:
coz the type predicate expects a function instead of a boolean
when we call equal it needs to take the args then return true instead of just returning the obolean

|#

; =============================================

#|
21.3 Every time we want to know something about a function that the user typed in, such as its number of arguments 
or its domain-checking predicate, we have to do an assoc in *the–functions*. That's inefficient. Instead, 
rewrite the program so that get–fn returns a function's entry from the a-list, instead of just its name. Then rename the 
variable fn–name to fn–entry in the functions–loop procedure, and rewrite the selectors scheme
procedure, arg–count, and so on, so that they don't invoke assoc.

answer:
|#

(define (get-fn)
  (display "Functions: ")
  (let* ((fn-name (read))
        (fn-entry (assoc fn-name *the–functions*))
        )
    fn-entry
    )
  )

(define (scheme–procedure fn–entry)
  (cadr fn–entry))
(define (arg-count fn-entry)
  (caddr fn-entry))
(define (type–predicate fn-entry)
  (cadddr fn-entry))
(define (error-msg fn-entry)
  (list-ref fn-entry 4)
  )


#|
(define (functions–loop)
  (let* ((fn–entry (get-fn))
         (fn-name (car fn–entry))
         )
    (if (equal? fn-name 'exit)
        "Thanks for using FUNCTIONS!"
        (let ((args (get-args (arg–count fn–entry))))
          (if (not (in–domain? args fn–entry))
              (show (error-msg fn–entry))
              (show-answer (apply (scheme–procedure fn–entry) args)))
          (functions–loop))))
  )
|#




; =============================================

#|
21.4 Currently, the program always gives the message ''argument(s) not in domain" when you try to apply a function to 
bad arguments. Modify the program so that each record in *the–functions* also contains a specific out-of
domain message like "both arguments must be numbers," then modify functions to look up and print this error 
message along with "argument(s) not in domain."

answer:


|#

; =============================================

#|
21.5 Modify the program so that it prompts for the arguments this way:
Page 385
Function: if
First Argument: #t
Second Argument: paperback
Third Argument: writer
The result is: PAPERBACK
but if there's only one argument, the program shouldn't say First:
Function: sqrt
Argument: 36
The result is 6
|#

; =============================================
#|
21.7 Why is the domain-checking predicate for the word? function
(lambda (x) #t)
instead of the following procedure?
(lambda (x) (word? x))

answer: coz its redundant, anything that goes inside (read) is a word in simply scheme

|#
; =============================================

;21.8 What is the value of the following Scheme expression?
(functions)

; =============================================

#|
21.9 We said in the recursion chapters that every recursive procedure has to have a base case and a recursive case, and 
that the recursive case has to somehow reduce the size of the problem, getting closer to the base case. How does the 
recursive call in get–fn reduce the size of the problem?

(define (get–fn)
  (display "Function: ")
  (let ((line (read–line)))
    (cond ((empty? line)
           (show "Please type a function!")
           (get–fn))
          ((not (= (count line) 1))
           (show "You typed more than one thing! Try again.")
           (get–fn))
          ((not (valid–fn–name? (first line)))
           (show "Sorry, that's not a function.")
           (get–fn))
          (else (first line)))))

answer:
get fn asks for users input until it eventually finds a function, and when it finds one
it asks for arg -> eval -> ends.
when it doesn't get any function taht match it keep asking
so it guarantees that the "problem" is being "reduced"

|#