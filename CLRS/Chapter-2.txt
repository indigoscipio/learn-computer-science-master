RAM model
is basically a simplified yet perfect, idealized pc
because algorithm speed is hard to measure we need a standard unit, thus the ram model is used

Time depends on input size & shape

Measuring input size
array = n
numbers = number of bits to represetn them
graphs= vertices, edges
pick a measure that makes sense


running time = how long your algorithm takes from start to finish
sum of (cost of operation x number of time it executes) 
sometimes it depends on the size of the input
and how already "sorted" the input is

Exercises
2.2-1
Express the function n^3/1000 - 100n^2 + 3 in terms of the O notation.

worst case = n^3. we can ignore the n^2 or constant
its a cubic function with power of 3

as the input grows larger, n^3 is the most dominant change

big O notation = On(n^3)

===========================================================

Exercise 2.2-1
Consider sorting n numbers stored in array A by first finding the smallest element
of A and exchanging it with the element in A[1]. Then find the second smallest
element of A, and exchange it with A[2]. Continue in this manner for the first n 1
elements of A. Write pseudocode for this algorithm, which is known as selection
sort. What loop invariant does this algorithm maintain? Why does it need to run
for only the first n 1 elements, rather than for all n elements? Give the best-case
and worst-case running times of selection sort in big O notation.

answer:
selection sort
first, find smallest element of A -> exchange with A[1]
second, find second smallest element of A -> exchange it with A[2]
continue until n-1 input

loop invariant: what needs to be true before, during and at the end?
the subarray a[1,...i-1] is sorted and contains i-1 smallest element of the original array. the remaining subarray is unsorted

initialization: before selection sort starts, the sorted array is empty, trivially contains 0 smallest element
Maintenance: if the first i-1 position contain i-1 smallest elment, then after swapping next smallest into a[i], now the first i position contain smallest i element
Termination: when i = n, the first n-1 position holds the smallest n-1 elements in sorted order. the last element is already sorted.


why it needs to rn only for the first n-1 element?
let see, first we need to find smallest element of the input
if the input is {1,9,4,5}
first we pick 1, put it into the first position
then 4, put it at 2nd,
then 5, put it in 3rd
finally 9 at the end - the 9 is already sorted by now
this is why we only need n-1

pseudocode:
let arr = [arr inputs]
let n = arr.length
let i = 1
while(i < n)
    let j = i+1
    let minIndex = i
    while(j < n)
        if arr[j] < arr[minIndex]
            minIndex = j
        j = j + 1
    end while
    swap arr[i] with arr[minIndex]
    i = i + 1
end while
    
Best case: the list is already sorted


while(i < n)
outer loop: runs n-1 times

while(j < n)
inner loop: runs n times


outer loop still iterates through n-1 times
inner loop still copmares all remainig elements ot find the minimum
big O notation: O(n^2)

Worst case: the list is sorted in reverse
outer loop still tierates through n-1 times
inner looop also still runs
big O notation: O(n^2)

Exercise 2.2-3
Consider linear search again (see Exercise 2.1-3). How many elements of the in
put sequence need to be checked on the average, assuming that the element being
searched for is equally likely to be any element in the array? How about in the
worst case? What are the average-case and worst-case running times of linear
search in big O notation? Justify your answers.

answer:
from exercise 2.1-3
let i = 1
 while i <= n
     if a[i] = v
        return i,
        i = i + 1
return nil

how many elements of the input seq needs to be checked on average?
if the input length is n then we need to check all of them until the item is found

best case item is at the start of the array, check 1 times => O(1)
worst case item is at the end of the array  => O(n)
average case item is in the middle of the array,  check 1+2+3+...+n/n times times => O(n)


2.2-4
How can we modify almost any algorithm to have a good best-case running time?
answer: by performing less computation
by adding a preliminary check at the begininng of the algorithm
the check should test if the input satisfies a condition that allows for a trivially fast answer

for sorting algorithm, best case input if it's already sorted, so add that check
for searching, check if arr[0] already contains the thing you're looking for

===========================================================

2.3
divide an conquer approach
1. divide problem into a number of subproblem, smlaler instances of the same problem

Merge sort example:
divide: divide n-element sequence to be sorted into two subsequences of n/2
conquer: sort the two subsequences recursively using merge sort
combine: merge the two sorted subsequence to produce the sorted answer

base case: trivally length is 1 (already sorted)


Loop invariant:
The portion of A we’ve filled so far already has the smallest elements in sorted order.
L[i] and R[j] are the next candidates to be placed.

===========================================================

Recurrence Relation
T(1) = c
T(n) = 2T(n/2) + cn for n > 1

Exercise 2.3-1
Using figure 2.4 as a model, illustrate the operation of merge sort on the array
A = {3,41,52,9}
initial sequence = {3,41,52, 26, 38, 57, 9, 49}
divide  -> {3,41,52, 26}, {38, 57, 9, 49}
{3,41} {52,26} {38,57} {9,49}
{3} {41} {52} {26} {38} {57} {9} {49}
conquer & merge -> {3,41} {26, 52}, {38, 57}, {9, 49}
{3, 26, 41, 52} {9,38,49,57}
{3, 9, 26, 38, 41, 49, 52, 57}

2.3-2
Rewrite the MERGE procedure so that it does not use sentinels, instead stopping
once either array L or R has had all its elements copied back to A and then copying
the remainder of the other array back into A.

Original pseudocode with sentinel:

where A= arr, p = 1st index, q = mid index, r = last index of the array
left half = A[p...q]
right half = A[q+1...r]

MERGE(A,p,q,r)
n1 = q - p + 1 ; length of left half
n2 = r - q  ;length of right half
let L[1...n1+1] and R[1...n2+1] be new arrys ;temporary array

for i = 1 to n1 ;loop from 1 to length of the left half + sentinel
    L[i] = A[p + i - 1] ; copy the content
for j = 1 to n2 ; loop from 1 to length of the right half + sentinel
    R[j] = A[q + j] ;copy the content
L[n1 + 1] = ∞ ;replace last item in left array with sentinel
R[n2 + 1] = ∞ ;replace last item in right array with sentinel

i = 1 ;index for left array, initialize to 1
j = 1 ;index for right arary, initialize to 1

for k = p to r ; loop from p to r (loop through the length of the original array)
    if L[i] <= R[j] ; compare curr item of L & R array at curr index, if left item is less than or equal to right item 
        A[k] = L[i] ; mutate the original array - replace its ocntent with left item
        i = i + 1 ; increase counter of the left array
    else A[k] = R[j] ; otherwise mutate original array's content with right item
        j = j + 1 ; increase counter of the right array


==================================================

Pseudocode without sentinel:

where A= arr, p = 1st index, q = mid index, r = last index of the array
left half = A[p...q]
right half = A[q+1...r]

MERGE(A,p,q,r)
n1 = q - p + 1 ; length of left half
n2 = r - q  ;length of right half
let L[1...n1] and R[1...n2] be new arrys ;temporary array

for i = 1 to n1 ;loop from 1 to length of the left half
    L[i] = A[p + i - 1] ; copy the content
for j = 1 to n2 ; loop from 1 to length of the right half
    R[j] = A[q + j] ;copy the content

k = p ;pointer for original array, start at p
i = 1 ;index for left array, initialize to 1
j = 1 ;index for right arary, initialize to 1

while i <= n1 and j <= n2 (loop while left & right arr is not empty)
    if L[i] <= R[j] ; pick smaller, advance index
        A[k] = L[i]
        i = i + 1
    else
        A[k] = R[j]
        j = j + 1
    k = k + 1

while i <= n1
    A[k] = L[i]
    i = i + 1
    k = k + 1

while j <= n2
    A[k] = R[j]
    j = j + 1
    k = k + 1

MERGE-SORT(A,p,r)
if p < r
    q = floor((p + r) / 2)
    MERGE-SORT(A,p,q)
    MERGE-SORT(A,q+1,r)
    MERGE(A,p,q,r)