RAM model
is basically a simplified yet perfect, idealized pc
because algorithm speed is hard to measure we need a standard unit, thus the ram model is used

Time depends on input size & shape

Measuring input size
array = n
numbers = number of bits to represetn them
graphs= vertices, edges
pick a measure that makes sense


running time = how long your algorithm takes from start to finish
sum of (cost of operation x number of time it executes) 
sometimes it depends on the size of the input
and how already "sorted" the input is

Exercises
2.2-1
Express the function n^3/1000 - 100n^2 + 3 in terms of the O notation.

worst case = n^3. we can ignore the n^2 or constant
its a cubic function with power of 3

as the input grows larger, n^3 is the most dominant change

big O notation = On(n^3)

===========================================================

Exercise 2.2-1
Consider sorting n numbers stored in array A by first finding the smallest element
of A and exchanging it with the element in A[1]. Then find the second smallest
element of A, and exchange it with A[2]. Continue in this manner for the first n 1
elements of A. Write pseudocode for this algorithm, which is known as selection
sort. What loop invariant does this algorithm maintain? Why does it need to run
for only the first n 1 elements, rather than for all n elements? Give the best-case
and worst-case running times of selection sort in big O notation.

answer:
selection sort
first, find smallest element of A -> exchange with A[1]
second, find second smallest element of A -> exchange it with A[2]
continue until n-1 input

loop invariant: what needs to be true before, during and at the end?
the subarray a[1,...i-1] is sorted and contains i-1 smallest element of the original array. the remaining subarray is unsorted

initialization: before selection sort starts, the sorted array is empty, trivially contains 0 smallest element
Maintenance: if the first i-1 position contain i-1 smallest elment, then after swapping next smallest into a[i], now the first i position contain smallest i element
Termination: when i = n, the first n-1 position holds the smallest n-1 elements in sorted order. the last element is already sorted.


why it needs to rn only for the first n-1 element?
let see, first we need to find smallest element of the input
if the input is {1,9,4,5}
first we pick 1, put it into the first position
then 4, put it at 2nd,
then 5, put it in 3rd
finally 9 at the end - the 9 is already sorted by now
this is why we only need n-1

pseudocode:
let arr = [arr inputs]
let n = arr.length
let i = 1
while(i < n)
    let j = i+1
    let minIndex = i
    while(j < n)
        if arr[j] < arr[minIndex]
            minIndex = j
        j = j + 1
    end while
    swap arr[i] with arr[minIndex]
    i = i + 1
end while
    
Best case: the list is already sorted


while(i < n)
outer loop: runs n-1 times

while(j < n)
inner loop: runs n times


outer loop still iterates through n-1 times
inner loop still copmares all remainig elements ot find the minimum
big O notation: O(n^2)

Worst case: the list is sorted in reverse
outer loop still tierates through n-1 times
inner looop also still runs
big O notation: O(n^2)

Exercise 2.2-3
Consider linear search again (see Exercise 2.1-3). How many elements of the in
put sequence need to be checked on the average, assuming that the element being
searched for is equally likely to be any element in the array? How about in the
worst case? What are the average-case and worst-case running times of linear
search in big O notation? Justify your answers.

answer:
from exercise 2.1-3
let i = 1
 while i <= n
     if a[i] = v
        return i,
        i = i + 1
return nil

how many elements of the input seq needs to be checked on average?
if the input length is n then we need to check all of them until the item is found

best case item is at the start of the array, check 1 times => O(1)
worst case item is at the end of the array  => O(n)
average case item is in the middle of the array,  check 1+2+3+...+n/n times times => O(n)


2.2-4
How can we modify almost any algorithm to have a good best-case running time?
answer: by performing less computation
by adding a preliminary check at the begininng of the algorithm
the check should test if the input satisfies a condition that allows for a trivially fast answer

for sorting algorithm, best case input if it's already sorted, so add that check
for searching, check if arr[0] already contains the thing you're looking for

===========================================================

2.3
divide an conquer approach
1. divide problem into a number of subproblem, smlaler instances of the same problem

Merge sort example:
