RAM model
is basically a simplified yet perfect, idealized pc
because algorithm speed is hard to measure we need a standard unit, thus the ram model is used

Time depends on input size & shape

Measuring input size
array = n
numbers = number of bits to represetn them
graphs= vertices, edges
pick a measure that makes sense


running time = how long your algorithm takes from start to finish
sum of (cost of operation x number of time it executes) 
sometimes it depends on the size of the input
and how already "sorted" the input is

Exercises
2.2-1
Express the function n^3/1000 - 100n^2 + 3 in terms of the O notation.

worst case = n^3. we can ignore the n^2 or constant
its a cubic function with power of 3

as the input grows larger, n^3 is the most dominant change

big O notation = On(n^3)

Exercise 2.2-1
Consider sorting n numbers stored in array A by first finding the smallest element
of A and exchanging it with the element in A[1]. Then find the second smallest
element of A, and exchange it with A[2]. Continue in this manner for the first n 1
elements of A. Write pseudocode for this algorithm, which is known as selection
sort. What loop invariant does this algorithm maintain? Why does it need to run
for only the first n 1 elements, rather than for all n elements? Give the best-case
and worst-case running times of selection sort in big O notation.

answer:
selection sort
first, find smallest element of A -> exchange with A[1]
second, find second smallest element of A -> exchange it with A[2]
continue until n-1 input

loop invariant: what needs to be true before, during and at the end?
the subarray a[1,...i-1] is sorted and contains i-1 smallest element of the original array. the remaining subarray is unsorted

initialization: before selection sort starts, the sorted array is empty, trivially contains 0 smallest element
Maintenance: if the first i-1 position contain i-1 smallest elment, then after swapping next smallest into a[i], now the first i position contain smallest i element
Termination: when i = n, the first n-1 position holds the smallest n-1 elements in sorted order. the last element is already sorted.


why it needs to rn only for the first n-1 element?
let see, first we need to find smallest element of the input
if the input is {1,9,4,5}
first we pick 1, put it into the first position
then 4, put it at 2nd,
then 5, put it in 3rd
finally 9 at the end - the 9 is already sorted by now
this is why we only need n-1


pseudocode:
let arr = [arr inputs]
let i = 1
let i_smallest = indexOf(min(arr))

while(i < n)
    //find the smalest element
    if arr[i] = arr[i_smallest] 
        //swap it and increment counter
        arr[i] = arr[i_smallest]
        i = i + 1
    // else keep finding
    else i = i + 1
    



Best case: ...
Worst case: ...