RAM model
is basically a simplified yet perfect, idealized pc
because algorithm speed is hard to measure we need a standard unit, thus the ram model is used

Time depends on input size & shape

Measuring input size
array = n
numbers = number of bits to represetn them
graphs= vertices, edges
pick a measure that makes sense


running time = how long your algorithm takes from start to finish
sum of (cost of operation x number of time it executes) 
sometimes it depends on the size of the input
and how already "sorted" the input is

Exercises
2.2-1
Express the function n^3/1000 - 100n^2 + 3 in terms of the O notation.

worst case = n^3. we can ignore the n^2 or constant
its a cubic function with power of 3

as the input grows larger, n^3 is the most dominant change

big O notation = On(n^3)

Exercise 2.2-1
Consider sorting n numbers stored in array A by first finding the smallest element
of A and exchanging it with the element in A[1]. Then find the second smallest
element of A, and exchange it with A[2]. Continue in this manner for the first n 1
elements of A. Write pseudocode for this algorithm, which is known as selection
sort. What loop invariant does this algorithm maintain? Why does it need to run
for only the first n 1 elements, rather than for all n elements? Give the best-case
and worst-case running times of selection sort in big O notation.

answer:
selection sort
first, find smallest element of A -> exchange with A[1]
second, find second smallest element of A -> exchange it with A[2]
continue until n-1 input

loop invariant: what needs to be true before, during and at the end?
the smallest should already be sorted 

why it needs to rn only for the first n-1 element
    becase the smallest one is already sorted


pseudocode:

