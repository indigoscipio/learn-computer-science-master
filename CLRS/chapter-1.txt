This is chapter 1 of CLRS

What is an algorithm?
It's a recipe that requires 3 things:
Input: ingredients
Algorithm: Steps
Output = cake

however its important that the steps be the following:
Precise: needs to be exac
Finite: needs to end

Algorithm can improve hardware
No matter how good the hardware is, if the algorithm sucks it will never be processed

Problem vs Instance of a problem
A good algorithm has a genearl input instead of to one specific instance

{1,2,3,5} = instance (number)
{A,B,C}, {1,2,5}, {"hey","hay"} = proglem

An algorithm is correct if it halts (stops) with the correct output

Why is sorting the most important algorithm?
Once everything is sorted, things can get easy
Searching - easier if its sorted
Deduplication - just search nearest neighbor
Merging

Data structure
Data structure is a container for idea, eg
what type of shape should my data have?

Exercises
 1.1-1
 Give a real-world example that requires sorting or a real-world example that re
quires computing a convex hull.
answer:
sorting: pretty much consumer/supermarket products eg eggs fruits etc in the factory you need to sort those
convex hull: in adobe software you need to outline a shape, calculateing specific area in GPS


 1.1-2
 Other than speed, what other measures of efficiency might one use in a real-world
 setting?
 answer: im guessing in the real world you measur efficiency along with time
 and risk, and how much money does it cost, etc.

 1.1-3
 Select a data structure that you have seen previously, and discuss its strengths and
 limitations.
 on top of my head:
 array: this stores one dimensional lists.
 pros: can group things togeter and define relationship. eg in js days=[Mon, Tue, Wed]. Very fast if its only little data.
 cons: depending on how you use it this can be slow to process eg if you store 1 million item in array its slow


 1.1-4
 How are the shortest-path and traveling-salesman problems given above similar?
 Howare they different?
shortest path algorithm asks: what's the shortest path from point A and point B?
you start in point A and ends in point B
traveling salesman asks: yit asks to visit some point exactly once and return home using the shortest route


 1.1-5
 Come up with a real-world problem in which only the best solution will do. Then
 come up with one in which a solution that is “approximately” the best is good
 enough.

 real world problem that requires best solution
 surgery: requires trained odctor with years of experience
 approximately best: recommendation engine, doesn't have to be perfect


  Exercises
 1.2-1
 Give an example of an application that requires algorithmic content at the applica
tion level, and discuss the function of the algorithms involved.
answer:
Navigation apps (Google Maps, Waze)
Task: Find the shortest route from point A to point B.
Algorithm: Shortest-path algorithms
Function: Compute routes quickly, considering distance, traffic, and possible paths.

 1.2-2
 Suppose we are comparing implementations of insertion sort and merge sort on the
 same machine. For inputs of size n, insertion sort runs in 8n^2 steps, while merge
 sort runs in 64nlgn steps. For which values of n does insertion sort beat merge
 sort?
 answer: 
 8 * n² < 64 * n * log₂(n)
 n^2 < 8 * n log2(n)
 n < 8 * log2(n)

 LHS = n grows linearly
 RHG = log curve grows slowly at first, then increases very slowly
 we need to find an approximatiion

n = 1
n = 1
log2(n) = 0
8*log2(n) = 0
n wins

n = 2
n = 2
log2(n) = 1
8*log2(n) = 8

n wins, but somewhere around n = 43 - 44 is where the inqueality flips which is thecrossover point


 1.2-3
 What is the smallest value of n such that an algorithm whose running time is 100n^2
 runs faster than an algorithm whose running time is 2^n on the same machine?

lets try it 
we need to find smallest value of n where 100n^2 runs faster than 2^n.
We need to find the approximation where the point crosses
n = 1
100n^2= 100
2^n= 2

n = 2
100(2)^2= 400
2^(2)= 4

n = 3
100(3)^2= 900
2^(3)= 8

n = 10
100(10)^2 = 10000
2^(16) = 1024

n = 14
100(14)^2 = 19600
2^(16) = 16384

n = 15
100(15)^2 = 22500
2^(15) = 32768

n = 16
100(16)^2 = 25600
2^(16) = 65536

the smallest value is n = 15


 Problems
 1-1 comparison of running times
 For each function f.n/ and time t in the following table, determine the largest
 size n of a problem that can be solved in time t, assuming that the algorithm to
 solve the problem takes f.n/ microseconds.

lg n: grows slowly for huge inputs, almost constant for most problem
sqrt(n): grows fater than log but slower than n
n: grows lineraly
n^2: quadratic growth to n
n^3: Cubic growth
2^n: exponential growth. time doubles with each addiitonal input
n!: grows the fastest



Insertion Sort
Sorting a list of number
best case: list of number is already sorted
worst case: its sorted in reverse


Exercises