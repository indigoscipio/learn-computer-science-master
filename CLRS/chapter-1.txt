This is chapter 1 of CLRS

What is an algorithm?
It's a recipe that requires 3 things:
Input: ingredients
Algorithm: Steps
Output = cake

however its important that the steps be the following:
Precise: needs to be exac
Finite: needs to end

Algorithm can improve hardware
No matter how good the hardware is, if the algorithm sucks it will never be processed

Problem vs Instance of a problem
A good algorithm has a genearl input instead of to one specific instance

{1,2,3,5} = instance (number)
{A,B,C}, {1,2,5}, {"hey","hay"} = proglem

An algorithm is correct if it halts (stops) with the correct output

Why is sorting the most important algorithm?
Once everything is sorted, things can get easy
Searching - easier if its sorted
Deduplication - just search nearest neighbor
Merging

Data structure
Data structure is a container for idea, eg
what type of shape should my data have?

Exercises
1.1-1
Give a real-world example that requires sorting or a real-world example that re
quires computing a convex hull.
answer:
sorting: pretty much consumer/supermarket products eg eggs fruits etc in the factory you need to sort those
convex hull: in adobe software you need to outline a shape, calculateing specific area in GPS


1.1-2
Other than speed, what other measures of efficiency might one use in a real-world
setting?
answer: im guessing in the real world you measur efficiency along with time
and risk, and how much money does it cost, etc.

1.1-3
Select a data structure that you have seen previously, and discuss its strengths and
limitations.
on top of my head:
array: this stores one dimensional lists.
pros: can group things togeter and define relationship. eg in js days=[Mon, Tue, Wed]. Very fast if its only little data.
cons: depending on how you use it this can be slow to process eg if you store 1 million item in array its slow


1.1-4
How are the shortest-path and traveling-salesman problems given above similar?
Howare they different?
shortest path algorithm asks: what's the shortest path from point A and point B?
you start in point A and ends in point B
traveling salesman asks: yit asks to visit some point exactly once and return home using the shortest route


1.1-5
Come up with a real-world problem in which only the best solution will do. Then
come up with one in which a solution that is “approximately” the best is good
enough.

real world problem that requires best solution
surgery: requires trained odctor with years of experience
approximately best: recommendation engine, doesn't have to be perfect


Exercises
1.2-1
Give an example of an application that requires algorithmic content at the applica
tion level, and discuss the function of the algorithms involved.
answer:
Navigation apps (Google Maps, Waze)
Task: Find the shortest route from point A to point B.
Algorithm: Shortest-path algorithms
Function: Compute routes quickly, considering distance, traffic, and possible paths.

1.2-2
Suppose we are comparing implementations of insertion sort and merge sort on the
same machine. For inputs of size n, insertion sort runs in 8n^2 steps, while merge
sort runs in 64nlgn steps. For which values of n does insertion sort beat merge
sort?
answer: 
8 * n² < 64 * n * log₂(n)
n^2 < 8 * n log2(n)
n < 8 * log2(n)

LHS = n grows linearly
RHG = log curve grows slowly at first, then increases very slowly
we need to find an approximatiion

n = 1
n = 1
log2(n) = 0
8*log2(n) = 0
n wins

n = 2
n = 2
log2(n) = 1
8*log2(n) = 8

n wins, but somewhere around n = 43 - 44 is where the inqueality flips which is thecrossover point


1.2-3
What is the smallest value of n such that an algorithm whose running time is 100n^2
runs faster than an algorithm whose running time is 2^n on the same machine?

lets try it 
we need to find smallest value of n where 100n^2 runs faster than 2^n.
We need to find the approximation where the point crosses
n = 1
100n^2= 100
2^n= 2

n = 2
100(2)^2= 400
2^(2)= 4

n = 3
100(3)^2= 900
2^(3)= 8

n = 10
100(10)^2 = 10000
2^(16) = 1024

n = 14
100(14)^2 = 19600
2^(16) = 16384

n = 15
100(15)^2 = 22500
2^(15) = 32768

n = 16
100(16)^2 = 25600
2^(16) = 65536

the smallest value is n = 15


Problems
1-1 comparison of running times
For each function f.n/ and time t in the following table, determine the largest
size n of a problem that can be solved in time t, assuming that the algorithm to
solve the problem takes f.n/ microseconds.

lg n: grows slowly for huge inputs, almost constant for most problem
sqrt(n): grows fater than log but slower than n
n: grows lineraly
n^2: quadratic growth to n
n^3: Cubic growth
2^n: exponential growth. time doubles with each addiitonal input
n!: grows the fastest



Insertion Sort
Sorting a list of number
best case: list of number is already sorted
worst case: its sorted in reverse


Exercises
2.1-1
Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the
array A = {31,41,59,26,41,58}

answer: iteration 1
sorted list = 31
curr target = 41
put 31 before 41 -> new sorted list = 31,41

iteration 2
sorted list = 31, 41
curr target = 59
put 59 after 41 -> new sorted list = 31,41,59

iteration 3
sorted list = 31,41,59
curr target = 26
put 26 before 31 -> new sorted list = 26, 31,41,59

iteration 4
sorted list = 31,41,59
curr target = 26
put 26 before 31 -> new sorted list = 21, 31,41,59

iteration 5
sorted list = 21, 31,41,59
curr target = 41
put 41  after 41 -> new sorted list = 21, 31,41, 41, 59

iteration 6
sorted list = 21, 31,41, 41, 59
curr target = 58
put 58 before 59 -> new sorted list =  21, 31,41, 41, 58, 59


no more items left
return new sorted list { 21, 31,41, 41, 58, 59}

2.1-2 rewrite insertion-sort procedure to sort into nonincreaseing instead of nondecreasing


2.1-3
Consider the searching problem
 Input: A sequence of n numbers A = {a1,a2,...,an} and a value v
 Output: An index i such that v = A[i] or the special value NIL if does not appear in A.

 Write pseudocode for linear search, which scans through the sequence, looking
 for v. Using a loop invariant, prove that your algorithm is correct. Make sure that
 your loop invariant fulfills the three necessary properties.

 let i = 1
 while i <= n
     if a[i] = v
        return i,
        i = i + 1
return nil

Invariant
before checking a[i], all elements before i do not contain v
initialization: before first iteration
base case is empty list
maintenance:
if see v, return It
otherwise recurse and increment i
termination: i will eventually reach n because of increment
when it reaches n return either nil or v, eventually terminate

2.1-4
Consider the problem of adding two n-bit binary integers, stored in two n-element
arrays A and B. The sum of the two integers should be stored in binary form in
an n+1 element array C. State the problem formally and write pseudocode for
adding the two integers.

answer:
input: arrays A, B representing n-bit integer
output: array C representing the sum in binary
each element A,B,C is either 0 or 1
C = sum of A + B

