#lang plai-typed

; ====================================
; TYPES

; lets keep it ArithC for now

; ARITHS
(define-type ArithS
  [numS (n : number)]
  [plusS (l : ArithS) (r : ArithS)]
  [bminusS (l : ArithS) (r : ArithS)]
  [multS (l : ArithS) (r : ArithS)]
  [uminusS (e : ArithS)]
  )

; EXPRESSION
; identifier is just the name
(define-type ExprC
  [numC (n : number)]
  [idC (s : symbol)]
  [plusC (l : ExprC) (r : ExprC)]
  [multC (l : ExprC) (r : ExprC)]
  [appC (f : ExprC) (a : ExprC)]
  [fdC (name : symbol) (arg : symbol) (body : ExprC)]
  )

; BINDING
(define-type Binding
  [bind (name : 'symbol) (value : Value)]
  )

(define-type-alias Env (listof Binding))
(define mt-env empty)
(define extend-env cons)

; VALUE
; can be eithera function or a number
(define-type Value
  [numV (n : number)]
  [funV (name : symbol)(arg : symbol)(body: ExprC)]
  )

; ====================================
#|
; DESUGAR
; when you desugar something, you turn arithS into arithC.
(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [numS (n) (numC n)]
    [plusS (l r) (plusC (desugar l) (desugar r))]
    [bminusS (l r) (plusC (desugar l) (multC (desugar r) (numC -1)) )]
    [multS (l r) (multC (desugar l) (desugar r))]
    [uminusS (e) (desugar (bminusS (numS 0) e)) ]
    )
  )
(desugar (numS 5))
(desugar (plusS (numS 3) (numS 8)))
(desugar (uminusS (numS 5)))
|#

; ====================================
; THE PARSER

#|
(define (parse [s : s-expression]) : ArithC
  (cond [(s-exp-number? s) (numC (s-exp->number s))]
        [(s-exp-list? s) (let* ((ls (s-exp->list s))
                                (fst (s-exp->symbol (first ls))))
                           (case fst
                             [(+) (plusC (parse (second ls)) (parse (third ls)))]
                             [(*) (multC (parse (second ls)) (parse (third ls)))]
                             [else (error 'parse "invalid list")])
                           
                           )]
        [else (error 'parse "not a valid input")]
        )
  )
;(parse '5)
;(parse '(+ 1 2))
;(parse '(+ (* 2 3) 5))
;(parse '(+ (* 1 2) (+ 2 3)))
|#

; ====================================

; NUM ARITHMETIC
(define (num+ [l : Value] [r : Value] : Value)
  (cond [(and (numV? l) (numV? r)) (numV (+ (numV-n l) (numV-n r)) ) ]
        [else (error "not a number")]
        )
  )

(define (num* [l : Value] [r : Value] : Value)
  (cond [(and (numV? l) (numV? r)) (numV (* (numV-n l) (numV-n r)) ) ]
        [else (error "not a number")]
        )
  )

; SUBST
; ExprC symbol ExprC -> ExprC
(define (subst [what : ExprC] [for : symbol] [in : ExprC]) : ExprC
  (type-case ExprC in
    [numC (n) in]
    [idC (s) (if (equal? s for)
                 what ;replace it
                 in)] 
    [appC (f a) (appC f (subst what for a))]
    [plusC (l r) (plusC (subst what for l) (subst what for r)) ]
    [multC (l r) (multC (subst what for l) (subst what for r))]
    )
  )
(subst (numC 7) 'n (plusC (idC 'n) (multC (numC 2) (idC 'n))))


; LOOKUP
(define (lookup [s : symbol] [env : Env]) : Value
  (cond [(empty? env) (error 'lookup "lookup not found")]
        [else (let ((fst-binding (first env)))
                (if (equal? (bind-name fst-binding) s)
                    (bind-value fst-binding)
                    (lookup s (rest env))
                    )
                )]
        )
  )

; THE INTERPRETER
(define (interp [e : ExprC] [env : Env] ) : Value
  (type-case ExprC e
    [numC (n) (numV n)]
    [plusC (l r) (+ (interp l env fds) (interp r env fds))]
    [multC (l r) (* (interp l env fds) (interp r env fds))]
    [idC (n) (lookup n env)]
 
    [appC (f a) (local ([define fd (interp f env)])
                  (interp (funV-body fd)
                          (extend-env (bind (funV-arg fd)
                                            (interp a env))
                                      mt-env)))
          ]

    [fdC (n a b) (funV n a b)]
    )
  )
;(interp (numC 8))
;(interp (plusC (numC 1) (numC 3)))
(test (interp (plusC (numC 10) (appC (fdC 'const5 '_ (numC 5)) (numC 10)))
mt-env)
(numV 15))



#|
DESUGARING

negation in terms of addition
a - b = a + (-1 . b)
|#
