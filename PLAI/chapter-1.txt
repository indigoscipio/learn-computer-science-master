Interpreter
consumes a program -> simulates execution
interpreter :: program -> Value

Compiler
consumes a proram -> produces another program
compiler :: program -> Program

JIT (just in time compilation)
eval starts as interpreter

==========================================

Remember

- language does not dictate implementations
- 2 types of implementation: interpretation and compilation
- these tyeps of implemenentation may offer interactive or non-interactive interface

(define (f x) (+ x 1))
(f 2)

(define (f x)) <- x is the formal parameter
(f 2) <- actual parameter

==========================================

Eager vs lazy evaluation
Eager (Applicative order evaluation)
(f (+ 5 4)) - evaluate arguments first
(f 9)
(+ 9 1)
10

Lazy (Normal Order)
Substitute first
(f (+ 5 4))
(+ x 1)
(+ (+ 5 4) 1)
(+ 9 1)

infinite data structure: possible with lazy

==========================================

- find a way to represent the program source
- look for the next expression to eval
- perform substitution to obtain new program
- continue evaluating until there's nothing left but value

how to best represent the data? ASTs - abstract syntax tree

==========================================

AST
Represnting ASTs
ASTs are tree structured data that represent programs in programs.
built on the ideas of 

Godel -> Encoding
Turing -> Universal Machine
Von Neumann -> stored program  computer
McCarthy -> Metacircular Interpreter

expression "Plus"
We have 2 types

(define-type Exp
[num: (n : Number)]
[Exp: (left: Exp) (right: Exp) ]
)

example
2.3 -> (num 2.3)
1 + 2 -> (plus (num 1) (num 2))
(1 + 2 )+ 3 -> (plus (plus (num 1) (num 2)) (num 3))

==========================================


Evaluating Arithmetic
Defining the evaluator

