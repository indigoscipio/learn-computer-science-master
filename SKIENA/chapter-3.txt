Data Structures

Contiguous vs Linked

Contiguous
Array -> each elmelent can be located by its index/house number
A street full of houses

+ instant time access/lookups
+ space efficent
+ memory locality
+ great for iteratiog

- cant do n+1 /more than n/fixed memory size
- resizing sucks

Linked
List, trees
houses that points to other houses,
to get address #500, you'd need to find house #1, hosue #2, etc

+ easy insertion/deletion
+ flexible memory allocation
- slow lookup
- not cache friendly

=================================

Pointers
connection that hold the piece of linked structures together, like a chain
represnts the address of a location



=================================

Stacks and queues

you put things in, you take things out later
the difference between stacks and queues is the rule that you decide
what to take out next.

Stack (LIFO)
cafetaria trays - only cares about the most recent item
- Undo functionality
- function call stack
- browser back button

Queue (FIFO)
movie ticket queue/orderly coffee shop
fair ordering
- ticket purchasing app
- print document
- BFS 


========================================

Dictionaries

is a storage system dhat does 3 things:
- insert
- delete
- search

key-value structure
keys are unique
hash table is a dicitionary

stop and think: comparing dictionary implementations

 Problem: What are the asymptotic worst-case running times for each of the seven
 fundamental dictionary operations (search, insert, delete, successor, predecessor,
 minimum, and maximum) when the data structure is implemented as:

 • An unsorted array.
 • Asorted array.

answer:
unsorted  array
search: you have to check the item 1 by 1 if you wanna earch for something , so worst case is O(n)
insert: since this is unserted O(1)
delete: finding the element is O(n) then shift 
successor: need to find the entire array, O(n)
predeccor: same as successor, O(n)
min: need to check all elements, O(n)
max: same as min, O(n)

 
sorted
search: we can use binary search, so O(log nn)
insert: the item inserted needs to be sorted so need to check each element 1 by 1 O(n)
delete: same as insert, check element 1 by 1 then shift O(n)
successor: o1
predeccor: o1
min: O(1) since its sorted, just get the head
max: O(1) same as min

read/write
read -> sorted
write -> unsorted


comparing dictionary implementations
singly linked unsorted list
search: since this is unsorted linked list it needs to check the whole item , so O(n)
insert: O(1), just insert it to the head
delete: find the item -> delete -> reassign pointer (update x predecessor so it points to x successor), O(n)
successor: find each item 1 by one, O(n)
predeccor: same as successor, O(n)
min: O(n)
max: O(n)

double  linked unsorted list
search: on
insert: o1
delete: o1
successor: on
predeccor: on
min: o1
max: o1

sorted linked list
search: stilll On
insert: O(n) since we need to check 1by1
delete: same as insert, O(n)
successor: On
predeccor: On
min: O1
max: O(n)

doubly linked sorted list
search: still O(n), need to check 1 by 1
insert: O(n), same as search
delete: O(n)
successor: since its sorted it should be O(1) right?
predeccor: O(1)
min: o1
max: o1 since we have tail pointer?


=====================

BST
search rule: if key is smaller than target, go to the left subtree
if the key is bigger than the target, go to the right subree

how it works
start at the root
at each node, make one comparison and move down one level (1 step)
repeat the process until we find the key or hit the end of the branch

degenerate tree - unbalanced

; A BinaryTree (BT) is one of:
; 1. '() ; The empty tree
; 2. (make-node number BT BT) ; A node with a 

-----

Searching
search(bt, target)
value = value(bt) ;get bt's root value
if value = null ; no more children to check, not found
    return null
if value = target ; target found
    return value
if value < target
    return search(bt_left, target) ;recurse to the left
    else return search(bt_right, target) ;recurse to the right
    
-----

Min-Max

-----

In-order traversal
list every item in order

-----

Insertion

-----

Deletion
the difficulty is in reassignment,
you can't just delete a node since it leaves a empty space

deleting 0 child - just delete leaf
deleting 1 child - pass to grandchild
deleting 2 child

=================

BST good and bad

Problem: You are given the task of reading n numbers and then printing them
out in sorted order. Suppose you have access to a balanced dictionary data struc
ture, which supports the operations search, insert, delete, minimum, maximum,
successor, and predecessor each in O(logn) time.
1. How can you sort in O(nlogn) time using only insert and in-order traversal?
answer:
so the task is reading, then writing them in sorted order
read -> print (in sorted order)

1. take all n inputs and put them in the dictionary
single number takes o(log n) * n = n log n

traversal = takes n time
so n log n + n > n log n dominates

2. How can you sort in O(nlogn) time using only minimum, successor, and
insert?
build structure
insert all items -> n . log n = n log n
cost for minimum = log n
cost of n -1 uscesor = (n-1) log n = n log n

total = n log n + n log n = n log n

3. How can you sort in O(nlogn) time using only minimum, insert, delete,
search?

build structure
insert all items -> n . log n = n log n

find minimum -> log n
print it -> 1
delete it -> log n
repeat

so one cycle is log n
we wana aply it to all n items
so n . log n = n log n

======================

Priority Queue
aka sort by importance

3 things:
Insert
find min, find max
delete

hospital emergency

===========================
Stop and think:
 Problem: What is the worst-case time complexity of the three basic priorityqueue
 operations (insert, find-minimum, and delete-minimum)
when the basic data structure is

• An unsorted array.
• Asorted array.
• Abalanced binary search tree.

answer:
unsorted array:
- insert: since its unsorted you can just insert at the beginning of an array? so O(1)?
i'm not sure if its the same with priority queue

- find min: check eaci item 1 by 1, O(n)

- delete min: check each item 1 by 1 and delete it so O(n)

sorted array:
- insert: O(n) since this is sorted
- find min: O(1), just the check the first item/heado f the array
- delete min: O(n), delete the first and shift the remaining array

balanced BST:
since bst is sorted
- insert: find (n log n) and insert to correct leaf
- find min: log n
- delete min: log n


=========================

Hash tbales
o1 lookup
turning search -> arithmetic
using modulo base 10 operators
different key uses different numbers

1. Calculate a number from your key (fast)
2. Use that number as an array index (instant)

Collusion
Chaining vs open addressing

3.3
a. worst case is size oscillation
everytime you perform an operation the size shrink -> grow, shrink, grow
bad amortized cost is O(n)

b. underflow strategy
choose a better shrink threshold lower than 1/2
1/4 or 1/8

3.4
direct access table

is an array where the index is the key
the key is an integer between 1 and n



3.5
a. all nodes store data, two child pointers, and parent pointer
data field needs 4 byte
each pointer require four bytes
answer: total pointer = 3 (2x child + parent) . 4 byte = 12 bytes
data field = 4.n bytes where n is the data

total space = 12 + 4 = 16 bytes
data space = 4 bytes

overhead fraction = 4/16 = 1/4 = 25%

this means 75% is allocated to structure
and 25% allocated to actual data

b. leaf node store data
internal node store two child pointer
data fields need 4 byte and each pointer need 2 byte

leaf node = node that has no children
internal node = node that has one or more children. this is the branching point, to allow
the tree to grow
2n / 2n+2n
1/2 = 50%

does having more memory allocation of data structure means good or bad?
what if its more memory allocation for poniter/ the other way around?

3.6
how to modify balanced tree data structure
such thatsearch, insert, delete, min,max, takes ologn time
but successor and predeccsor take 01

which operation hve to be modified?
answer:
we know that searching takes o log n

answer:
in binary tree usually sucessor and predeceesor takes o logn 
coz you have to climb up/down tree

the solution is to find its prev/next node in sorted order
every node needs to store two extra pointers:
- poitner to its sucessor (next node in sorted order)
- pointer to its predeccesor (prev node in sorted order)

modififcations needed to be made
insertion and deletion since they mofidy the structure/order of the tree
min,max and search only reads the data

insert:
set x's rped and success to new neighbor
set neighbours pred ans suc to point to x

delete:
when x is deleted, pred of a and succ b becomes neighbouring
- update a's succ to poitn to b
- update b's pred to point to a

3.7
store the current min/max value outside the data structure
insert -> search, insert = o log n + o1

delete -> search o log n

3.8
design a data structure to support the following operations
a. insert(x,t) - insert item x into the set t
b. delete(k,t)
c. member(x,T)
All operations must take O(logn)timeonann-element set.

for unsorted array
insert: o1, just insert at the head
delete: search and delete, takes O(n)
member: same, O(n)

for bbst:
insert: o log n since its sorted, find the spot and insert
member: saerch based on height
delete: search to find element, deletion, rebalance


3.9
seperate s1 and s2
find the mid ground - new root -> maximum of s1
isolate the subtree - delete s1max from s1
join the tree with kmax as the root
rebalnce the tree

stotal = s1 (without s1max), kmax, s2


3.10

n metal objects
0 - 1 kg
find smallest number of bins that will hold the n objects
with each bin holding one kg

3.11

input = n
weights = w1, w2, w3 ...
output = number of bins used

bbst data structure
key = remaining capacity

find a bin whose capacity is >= current weight (it fits)
and is te smallest possible value that satifsies the fit condition (snuggest fit)
perform successor on bbst
if bin is found, calculate new capacity, delete old capacity from bst and insert new capacity
if no bin is found, start a new bin and insert its initial remaining capacity


worst fit
find maximum capcaity max()
if max capacity >= wi, use that bin and update its capacity. 
if max capacity <= wi, start  a new bin and insert its initial remaining capcity

3.11

n values x1,x2, ... xn
gien i and j, find smallest value in xi, ... xj
basically find smallest value within a range

a. design data structure that uses O(n^2) space and answers queries in O(1) time
o1 query -> store min value in lookup table

lookup table M[i][j] = minimum of the sequence
on^2 -> check each minimum in the table
o1 -> compute current min using prev min

total = on^2 . o1 = on^2

3.12

input: set S of n numbers
given any sequence of real numbers and integer k
instantly and correctly answers wheter there is a subset of input sequence whose sum is exactly k

what is subset sum problem? SSP
does there exist subset of S whose sum is exactly up to k?

initialiation: start with original set S and target k
the solution set A = empty set

loop through i=1 to n
test: ask black box if solution existsin the remaining elements for the current target k
if it exists: xi is optional, skip and leave k unchanged
if it doesn't exsist: add x1 to a and update k -> k - xi

final: a is subset that sums the rogiinal target k


3.13
A[1...n] is an array of real numbres
design algorithm to perform:

1. add(i,y) - add value y to the ith number
2. partial-sum(i) - return sum of the first i numbers,

no insertion or deletion,
only change the valus of the numbers
should take o log n steps
use one additional array of size n

3.15

3.18
the words are sotred

3.19

3.20
function to find middle node of a single linked list
turtle and hare thing

3.24

hash table but memory problem
Bloom Filter

3.25
search string and magazine
i want to generate all chars in search string by curring them out from the mag

using a hash map
1, build inventory
"hello world" ->
h = 1, e = 2, ...
if a char is not on the table, add it

time complexity = M . O(1) = O(M)
so it depends on the input M/proportional

step 2
lookup each char on the string and compare
O(1) . O(S) = O(S)

total = O(M) + O(S) = O(M + S)
