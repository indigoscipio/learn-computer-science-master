RAM Modeling

Addiiton, mult, comparison = 1 step
Memory read/write= 1step


Big O
measures number of steps grows
as the input size n grows
it measure growth rate, not runtime
what is the shape of the curve?

O(n²) = “you’ll never go faster than n² steps”

Ω(n) = “you’ll always go at least n steps”

Θ(n log n) = “you consistently hover around n log n steps”


===========

f(n) = Your actual travel time in a specific car

g(n) = Travel time of a rocket bike

If you say "My car is O(rocket bike)", you're saying: 
On a long enough road, my car will never be slower than a rocket bike.
The rocket bike is a valid upper bound for my car's speed."

O = "Won't be worse than..." (Upper bound)

Ω = "Won't be better than..." (Lower bound)

Θ = "Grows exactly like..." (Tight bound - most informative!)

===========

Problem: 
is (x + y)^2 = O(x^2 + y^2)?

answer:
by the definitino of O(n), f(n) = O(g(n)) iff there exists constant c
such that  n f (n) <= c g(n)
(x+y)^2 <= (x^2 + y^2) for some constant c

LHS
(x + y) (x + y) 
= x^2 + 2xy + y^2 <= c(x^2 + y^2) for all sufficiently large x,y

we need to show 2xy is less than or equal to some constant times (x^2 + y^2)

since we know any real number squared is always >= 0
(x-y)^2 >= 0
(x^2 + 2xy + y^2) >= 0
x^2 + y^2 >= 2xy

x² + 2xy + y² ≤ x² + (x² + y²) + y²



 ===================

 Stop and think: transitive experience
 problem: show that big o relationship are transitive.
that is, if f (n) = O (g(n)) and
g(n) = O(h(n)), then f(n) = O(h(n))

answer:

f(n) = O(g(n))
by definition, f(n) = o(g(n)) iff there exists constant c such that 
n . f(n) <= c g(n)
this means f grows much slower than g

g(n) = O(h(n))
n . g(n) <= c h(n)
this means g grows slower than h

therefore if f < g, then g < h
so f < g < h

Stop and think:
importance of an even split

problem: how many queries does binary search take
on the million-name manhattan phonebook if each split was 1/3 to 2/3 instead of 1/2 to 1/2?

answer:
original binary search -> log base 2 of n
each iteration you divide by half until its found

if each split was 1/3 to 2/3
log base 3 of n -> divide by 1/3?
my guess is growth rate is tsill the same by log n since changing the base doesn't matter?

2.10
Exercises

Program analysis

2.1
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using the Big Oh notation.

function mystery(n)
r := 0
for i := 1 to n−1 do
    for j := i+1 to n do
        for k := 1 to j do
            r := r+1
return(r)

 a. what is the value returned?
answer: lets trace this with n = 3
lets try another input
mystery(3)
r = 0
outer loop: i = 1  to 2

when i = 1
    mid loop
    j = 2 to 3
    
    j = 2
        inner loop: k = 1 to j
        k = 1 to 2
        k = 1 -> r + 1 = 1
        k = 2 -> r + 1 = 2
    
    j = 3
        inner loop: k = 1 to j
        k = 1 to 3
        k = 1 -> r + 1 = 3
        k = 2 -> r + 1 = 4
        k = 3 -> r + 1 = 5

when i = 2
    mid loop
    j = 3 to 3

    j = 3
        inner loop: k = 1 to 3
        k = 1 -> r + 1 = 6
        k = 2 -> r + 1 = 7
        k = 3 -> r + 1 = 8

return 8

mystery(4)
r = 0
outer loop: i = 1  to 3

i = 1
    j = 2 to 4
    j = 2
        k = 1 to 2
        k = 1
            r = 0 + 1 = 1
        k = 2
            r = 1 + 1 = 2
    j = 3
        k = 1 to 3
        k = 1
            r = 2 + 1 = 3
        k = 2
            r = 3 + 1 = 4
        k = 3
            r = 4 + 1 = 5
    j = 4
        k = 1 to 4
        k = 1
            r = 5 + 1 = 6
        k = 2
            r = 6 + 1 = 7
        k = 3
            r = 7 + 1 = 8
        k = 4
            r = 8 + 1 = 9

i = 2
    j = 3 to 4
    j = 3
        k = 1 to 3
        k = 1
            r = 10
        k = 2
            r = 11
        k = 3
            r = 12
    j = 4
        k = 1 to 4
        k = 1
            r = 13
        k = 2
            r = 14
        k = 3
            r = 15
        k = 4
            r = 16

i = 3
    j = 4 to 4
    j = 4
        k = 1 to 4
        k = 1
            r = 17
        k = 2
            r = 18
        k = 3
            r = 19
        k = 4
            r = 20

return r = 20

n(3) return 8
n(4) returns 20
it seems to me the function acts like a simple countre
but designed by nested loops

 b. worst case running time using big O notation
 since the function has 3 loops,
 that's n * n * n + 1 operation = n^3+1
 so in terms of big O notation =  O(n^3)

 2.2 what value is returned by the following function?
 express your answer as a function of n
 give worst-case running time using big o notation

function pesky(n)
r = 0
for i := 1 to n do
    for j := 1 to i do
        for k := j to i+j do
            r := r+1
return(r)

answer:
lets trace pesky(1)
r = 0
outer -> i = 1 to 1

i = 1
    j = 1 to 1
    j = 1
        k = 1 to 2
        k = 1
            r = 0 + 1 = 1
        k = 2
            r = 1 + 1 = 2
return 2

pesky(2)
r = 0
ouer -> i = 1 to 2
i = 1
    j = 1 to 2
    j = 1
        k = 1 to 2
        k = 1
            r = 0 + 1 = 1
        k = 2
            r = 2
    j = 2
        k = 2 to 3
        k = 2
            r = 3
        k = 3
            r = 4

i = 2
    j = 1 to 2
    j = 1
        k = 1 to 3
        k = 1
            r = 5
        k = 2
            r = 6
        k = 3
            r = 7
    j = 2
        k = 2 to 4
        k = 2
            r = 8
        k = 3
            r = 9
        k = 4
            r = 10
return 10

pattern: n=1 return 2, n=2 return 10
the sum from i=1 to n + the sum of j=1 to i of i + j

worst case running time: feels limilar to toe previous triangular thing
n * n * n since its 3 loops??

2-3
 2.2 what value is returned by the following function?
 express your answer as a function of n
 give worst-case running time using big o notation

function prestiferous(n)
r:= 0
 for i := 1 to n do
    for j := 1 to i do
        for k := j to i+j do
            for l := 1 to i+j −k do
             r := r+1
return(r)
similar to the previous one

trace example
r = 1

outer loop
i = 1 to 1
i = 1
    j = 1 to 1
    j = 1
        k = 1 to 2
        k = 1
            l = 1 to 1
        k = 2
            l = 1 to 0

worse case = 4  loops = n *n * n * n
it only runs when i + j - k > 0
O(n^4)

2.4 
 2.2 what value is returned by the following function?
 express your answer as a function of n
 give worst-case running time using big o notation

function conondrum(n)
r := 0
    for i := 1 to n do
        for j := i+1to n do
            for k := i+j −1 to n do
                r := r+1
return(r)

inner loop k runs when i + j - 1 < n

2.5
suppose the following algorithm is used to evaluate polynomial
p(x) = anx^n + an-1x^n-1 + ... + a1x + a0

p:= a0 ; lowest term?
xpower := 1 ; curr power? initialize power to 1
for i:=1 to n do
    xpower := x * xpower
    p:= p + ai * xpower
end

a. how many multpilications are done in the worst case? how many additions?
b. how many multiplications are done on the average?
c. can you improve this algorithm?

answer:
a. worst case:
if there are many terms
the main loop:

runs from 1 to n
only do one mltiplication and one addition
that is, update xpower to x * xpower
and update p to p + ai * xpower
for each terms,
so for the whole algorithm

pre loop + (operations per iteration * n)

b. how many multplications are done on the average?
Since the algorithm does the exact same work regardless of the coefficient values, the average case is identical to the worst case.



c. horner;s rule
accumulate the sum of term multiplications inside a variable
and sum it each iteration

2.6
prove that the following algorithm for computing the maximum value in a narray A[1...n]
is correct


function max(A)
    m:=A[1] ;set current max  value to first item in array A
    for i := 2 to n do  ; loop from 2nd item to n (total array length)
        if A[i] > m then m := A[i] ; check if current item's value is greater than m, if so this is new max found so far
    return (m)


initialization:
before the start of the iteration, m: A[1]
set the current max value to the Array's first item
since we've only seen one element so far, m correctly holds the maximum of the subarray A[1..1]

maintenance:
at the start of each iteration, the loop checks for the next current item of the ARray
it checks if there is a item greater than temporary max item initialized

assume m holds the maximum of a[1...i-1]. After comparing with A[i] m becomes max(m,A[i]) which is the maximums of A[1..i]

terminateion
loop terminates when i = n + 1
 At this point, m holds the maximum of A[1..n], which is exactly what we return.

 Big Oh

 2.7
 true or false?
 a. is 2^n+1 = O(2^n)?
 b. is 2^2n = O(2^n)?

 answer:
a. true because 2^n+1 is just 2^n . 2^1 which is just O(2^n)
b. false because 2^2n <= 2^n . c

2.8
for each of the following pairs of funciton,
either f(n) is in O(g(n)),
f(n) is in Omega(g(n)),
or f(n) = theta(g(n)) determine correct relationship and explain why

a. f(n) = log n^2;
g(n) = log n + 5

fn dominant growth = log n^2 = 2 . log(n)
gn dominant growth = log n

since the grows are the same
lowre bound is the same and upper bound is the same therefore 
f(n) is in theta(g(n))

b. 