RAM Modeling

Addiiton, mult, comparison = 1 step
Memory read/write= 1step


Big O
measures number of steps grows
as the input size n grows
it measure growth rate, not runtime
what is the shape of the curve?

O(n²) = “you’ll never go faster than n² steps”

Ω(n) = “you’ll always go at least n steps”

Θ(n log n) = “you consistently hover around n log n steps”


===========

f(n) = Your actual travel time in a specific car

g(n) = Travel time of a rocket bike

If you say "My car is O(rocket bike)", you're saying: 
On a long enough road, my car will never be slower than a rocket bike.
The rocket bike is a valid upper bound for my car's speed."

O = "Won't be worse than..." (Upper bound)

Ω = "Won't be better than..." (Lower bound)

Θ = "Grows exactly like..." (Tight bound - most informative!)

===========

Problem: 
is (x + y)^2 = O(x^2 + y^2)?

answer:
by the definitino of O(n), f(n) = O(g(n)) iff there exists constant c
such that  n f (n) <= c g(n)
(x+y)^2 <= (x^2 + y^2) for some constant c

LHS
(x + y) (x + y) 
= x^2 + 2xy + y^2 <= c(x^2 + y^2) for all sufficiently large x,y

we need to show 2xy is less than or equal to some constant times (x^2 + y^2)

since we know any real number squared is always >= 0
(x-y)^2 >= 0
(x^2 + 2xy + y^2) >= 0
x^2 + y^2 >= 2xy

x² + 2xy + y² ≤ x² + (x² + y²) + y²



 ===================

 Stop and think: transitive experience
 problem: show that big o relationship are transitive.
that is, if f (n) = O (g(n)) and
g(n) = O(h(n)), then f(n) = O(h(n))

answer:

f(n) = O(g(n))
by definition, f(n) = o(g(n)) iff there exists constant c such that 
n . f(n) <= c g(n)
this means f grows much slower than g

g(n) = O(h(n))
n . g(n) <= c h(n)
this means g grows slower than h

therefore if f < g, then g < h
so f < g < h

Stop and think:
importance of an even split

problem: how many queries does binary search take
on the million-name manhattan phonebook if each split was 1/3 to 2/3 instead of 1/2 to 1/2?

answer:
original binary search -> log base 2 of n
each iteration you divide by half until its found

if each split was 1/3 to 2/3
log base 3 of n -> divide by 1/3?
my guess is growth rate is tsill the same by log n since changing the base doesn't matter?

2.10
Exercises

Program analysis

2.1
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using the Big Oh notation.

function mystery(n)
r := 0
for i := 1 to n−1 do
    for j := i+1 to n do
        for k := 1 to j do
            r := r+1
return(r)

 a. what is the value returned?
answer: lets trace this with n = 3
lets try another input
mystery(3)
r = 0
outer loop: i = 1  to 2

when i = 1
    mid loop
    j = 2 to 3
    
    j = 2
        inner loop: k = 1 to j
        k = 1 to 2
        k = 1 -> r + 1 = 1
        k = 2 -> r + 1 = 2
    
    j = 3
        inner loop: k = 1 to j
        k = 1 to 3
        k = 1 -> r + 1 = 3
        k = 2 -> r + 1 = 4
        k = 3 -> r + 1 = 5

when i = 2
    mid loop
    j = 3 to 3

    j = 3
        inner loop: k = 1 to 3
        k = 1 -> r + 1 = 6
        k = 2 -> r + 1 = 7
        k = 3 -> r + 1 = 8

return 8

mystery(4)
r = 0
outer loop: i = 1  to 3

i = 1
    j = 2 to 4
    j = 2
        k = 1 to 2
        k = 1
            r = 0 + 1 = 1
        k = 2
            r = 1 + 1 = 2
    j = 3
        k = 1 to 3
        k = 1
            r = 2 + 1 = 3
        k = 2
            r = 3 + 1 = 4
        k = 3
            r = 4 + 1 = 5
    j = 4
        k = 1 to 4
        k = 1
            r = 5 + 1 = 6
        k = 2
            r = 6 + 1 = 7
        k = 3
            r = 7 + 1 = 8
        k = 4
            r = 8 + 1 = 9

i = 2
    j = 3 to 4
    j = 3
        k = 1 to 3
        k = 1
            r = 10
        k = 2
            r = 11
        k = 3
            r = 12
    j = 4
        k = 1 to 4
        k = 1
            r = 13
        k = 2
            r = 14
        k = 3
            r = 15
        k = 4
            r = 16

i = 3
    j = 4 to 4
    j = 4
        k = 1 to 4
        k = 1
            r = 17
        k = 2
            r = 18
        k = 3
            r = 19
        k = 4
            r = 20

return r = 20

n(3) return 8
n(4) returns 20
it seems to me the function acts like a simple countre
but designed by nested loops

 b. worst case running time using big O notation
 since the function has 3 loops,
 that's n * n * n + 1 operation = n^3+1
 so in terms of big O notation =  O(n^3)

 2.2 what value is returned by the following function?
 express your answer as a function of n
 give worst-case running time using big o notation

function pesky(n)
r = 0
for i := 1 to n do
    for j := 1 to i do
        for k := j to i+j do
            r := r+1
return(r)