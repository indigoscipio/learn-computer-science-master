

Problem vs Instance
Problem = the general goal
Instance = specific example of a goal

TSP/Traveling Salesman Problem

Nearest Neighbour -> less optimal because of potential "zig zag"

Connect Pair -> Pair points that are the closest, gradually connect small cluster
potentially can connect across row creating a "tangled" route

Perfect algorithm -> Brute Force

_____________________

Interval scheduling Problem

stop and think: incremental correctnes

problem: prove correctness of the following alg for incrementing natural number
y -> y + 1

increment(y)
    if y = 0 then return (1)
        if (y mod 2) = 1 then ; if its an even number
            reutrn (2 . increment(floor(y/2)))
        else return (y+1) ; if its an odd number, increase y by 1


base case: when y reaches 0, return 1
how about if its a negative integer?
does it termintae?

if case -> y mod 2 = 1
recurse with new y = floor(y/2) . 2
else increment y by 1

case where its odd
let y = 3
2 . increment(floor(3/2))
2 . increment(1)
then inside increment(1)
2 . increment(floor(1/2))
2 . increment(0)
2 . 2 . 1 = 4

case where its even
just increse it by 1
let y = 2
return y + 1 -> 3, which is true even for any even numbers

base: y = 0, increment by 1 which is 1 so correct
assume: assume it works for all values less than n
prove: therefore works for y = n

floor(y/2) -> remove the last binary digit (right shift)
11 (3) -> 1 (1)
101 (5) -> 10 (2)

2 . x -> add 0 to the end in binary
10 (2) -> 100 (4)
11 (3) -> 110 (6)

y = 2m+1

increment(2m+1) -> 
2 . increment(floor(y/2)) -> 2 . increment(floor(2m+1/2)) -> 2 . increment(m)

IH -> increment(m) = m+1

2 . (m+1) = 2m + 2 -> (2m+1) + 1 = y + 1

_______________________

stop and think: factorial formulae

problem: prove that summation from i=1 to n of i * i! = (n+1)! - 1 by induction


base: n=1
sum from i = 1 to 1 of 1 * 1! = 1
(n+1)! - 1 = 2! - 1 = 2.1 - 1 = 1
they are equal

n = 2
2 * 2! + 1 * 1! = 2 * 2 + 1 = 5
3! - 1 = 5
they are equal

seems to be true for smaller base case

assume: it works for some n = k
by the definition of factorial n! = n . n-1!
Sk = (k+1)! - 1 -> IH

prove: it must then work for n = k + 1
Sk+1 = Sk + k+1 * k+1!
Sk+1 = (k+1)! - 1 + k+1 * k+1!
sk+1 = k+1! (1 + k+1) - 1
sk+1 = k+1! (k+2) - 1
sk+1 = k+2! - 1


_____________________
Modeling means turning a messy real-world problem into a clean math or logic problem that we already understand.

permutation problm
what order should i do these things?
- robot tour
- sorting
- scheduling

subsets problem
which items should i choose?
order doesn't matter
- choosing members
- movie scheduling

Tree Problem
hierarchical parent/child relationship
- company orgs chart
- file system
- decision tree
- family tree
- categories, subcategories

graphs problem
anything connected to anything else
- road maps
- social network
- computer networ

points problem
- location in space
- location on map
-stars in astronomy

strings problem
- dna seq
- text docs


_____________________

Exercises

1-1
show that a+b can be less than min(a,b)

lets pick a small example
let a = -1
let b = -2

a+b = -1 -2 = -3
min(a,b) = min(-1,-2) = -2

-3 < -2? true
therefore shown

1-2 show that axb can be less than min(a,b)

lets pick an example
a = -1
b = 2

a x b = -1 * 2 = -2
min(a,b) = min(-1,2 = -1)

therefore axb < min(a,b)

1-5

The knapsack problem is as follows: given a set of integers S = {s1,s2,...,sn},
 and a target number T, find a subset of S which adds up exactly to T. For example,
 there exists a subset within S = {1,2,5,9,10} that adds up to T = 22 but not
 T =23.

 Find counterexamples to each of the following algorithms for the knapsack problem.
 That is, giving an S and T such that the subset is selected using the algorithm does
 not leave the knapsack completely full, even though such a solution exists.

a. put the elements of s in the knapsack in left to right order if they fit.
ie the first fit algorithm

b. put the elements of s in the knapsack from smallest to largest. ie tbest fir lagorithm

c. put the elements of s in the knpsack from largest to smallest


answer:
a. this would fail because it fails to plan ahdead
it doesn't know what the unchecked part is
counterexample: 
let T = 6
S={2,3,3}

b. smallest to largest and it fails
it fails because it waste space early
it has no room left for single large item
counterexample:
let S = {1,2,2,6}
let T = 6


c. largest to smallest and why it fails
it fails because it checks too early/short sighted
can block combination of smaller numbers that would fit the target perfectly

counterexample:
let S = {5,3,3}
let T = 6

1-6
The set cover problem is as follows: given a set of subsets S1,...,Sm of the
 universal set U = {1,...,n}, find the smallest subset of subsets T âŠ‚ S such that
Uti E TTi = U. For example, there are the following subsets, S1 = {1,3,5}, S2 =
 {2,4}, S3 = {1,4},andS4 = {2,5} The set cover would then be S1 and S2.
 Find a counterexample for the following algorithm: Select the largest subset for the
 cover, and then delete all its elements from the universal set. Repeat by adding the
 subset containing the largest number of uncovered elements until all are covered.

 countereample
s1 = {1,2,3,4}
s2 = {1,2,3}
s3 = {4,5}

Proofs of correctness
1-7. prove the correctness of the following recursive algorithm to multiply two natural numbers,
for all integer constants c>= 2

function multiply(2)
    ; return the product yz
    if z = 0
        return 0
    else
        return multiply(cy, floor(z/c)) + y . (z mod c)