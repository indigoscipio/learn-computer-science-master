#lang racket


;e1 : true branch, e2: false branch, c: the selector/decider -> comes at last
; cond:: λe1.λe2.λc.((c e1) e2)
(define lc-cond (λ (e1) (λ (e2) (λ (c) ((c e1) e2) ))) )

; identity:: λf.f
(define identity (λ(f) f))

; apply:: λf.λg.(f g)
(define apply (λ(f)
                (λ (g)
                  (f g))))

; select-first:: λf.λs.f
(define select-first (λ (f) (λ (s) f )))

; select-second:: λf.λs.s
(define select-second (λ (f) (λ (s) s )))

; self-apply:: λs(s s)
(define self-apply (λ (s) (s s) ))

; make-pair: λfirst.λsecond.λfunc((func first) second)
(define make-pair (λ (first) (lambda (second) (lambda (func) ((func first) second) ) ) ))


; not: X ? FALSE : TRUE
; not:: λx.(((cond false) true))
; not:: λx.((x false) true) - simplified version
(define lc-not (λ (x) (((lc-cond false) true) x)))

; and:: X ? Y : FALSE
; and:: λx.λy.(((cond y) false) x)
; and:: λx.λy.((x y) false) - simplified version
(define lc-and (λ (x) (λ (y) (((lc-cond y) false) x) )))

; or:: X ? TRUE : Y
; or:: λx.λy.(((cond true) y) x)
; or:: λx.λy.((x true) y) - simplified version
(define lc-or (λ (x) (λ (y) ((x true) y) ) ) )

; is-zero?:: λn.(n select-first)
(define is-zero? (lambda (n) (n select-first)))


; succ: λn.λs.((s false) n)
(define succ (λ (n) (λ (s) ((s false) n) ) ))

; pred: λn.(((iszero n) zero) (n select-second))
(define pred (λ x x))

; add2:: ...
(define add2 (λ (f) (λ (x) (λ (y) (if (is-zero? y) x (((f f) (succ x) (pred y))) ) )) ))

#|
====== OPERATION - ADDITION ======

def add x y =
if iszero y
then x
else add (succ x) (pred y)

(add one two) =>
(add (succ one) (pred two)) =>
(add (succ (succ one)) (pred (pred two)) ) =>
(succ (succ one)) == three

how can a function call itself if it doesn't have a name yet?
hand out 2 things: the current work and the copy of instrunction for the next person
to "carry" the funcion's own code as an argument so it remembers

so the fix

def add2 f x y
if iszero y
then x
else f f (succ x)(pred y)

def add = add2 add2
whici is the same as
(add2 add2) - still waiting for the 2 rest arguments to be used

add one two ==
λx.λy.
if iszero y
then x
else (add2 add2 (succ x) (pred y) one two) =>
... =>

if iszero two
then one
else add2 add2 (succ one) (pred two) =>

λf.λx.λy.
if iszero y
then x
else (add2 add2 (succ x) (pred y) add2 (succ one) (pred two)) =>
...

if iszero (pred two)
then (succ one)
else add2 add2 (succ (succ one)) (pred (pred two)) =>

λf.λx.λy.
if iszero y
then x
else (add2 add2 (succ x) (pred y) add2 (succ (succ one)) (pred (pred two))) =>
...

if iszero (pred (pred two))
then (succ (succ one))
else add2 add2 (succ (succ (succ one))) (pred (pred (pred two))) =>

(succ (succ one)) == three

====== OPERATION - MULTIPLICATION ======

def mult x y
if iszero y
then zero
else add x (mult x (pred y))

mult three two => ... =>
add three (mult three (pred two)) -> ... ->
add three (add three (mult three (pred (pred two)))) ->
add three (add three zero) -> ... ->
add three three => ... =>
six

def mult1 f x y
if iszero y
then zero
else add x (f x (pred y))

def mult = recursive mult1
def recursive f = f <'f' and copy>

apply recursive to mult1
f <'f' and copy> mult1 =>
mult1 <mult1 and copy> =>

(λf.λx.λy.
if iszero y
then zero
else add x (f x (pred y)) <mult1 and copy>) =>


if iszero y
then zero
else add x (<mult1 and copy> x (pred y))

(<mult1 and copy> x (pred y) =>

-----
def recursive f = (λs.(f (s s)) λs.(f (s s)))
-----

mult three two => ... =>
(λx.λy.
if iszero y
then zero
else add x ( (λs.(mult1 (s s)) λs.(mult1 (s s))) x (pred y)) three two) => ... =>

if iszero two
then zero
else add three (λs.(mult1 (s s)) λs.(mult1 (s s))) three (pred two)) => ... =>

add three (λs.(mult1 (s s)) λs.(mult1 (s s))) three (pred two)) ->
add three (mult1 (λs.(mult1 (s s)) λs.(mult1 (s s)))  three (pred two)) ==

add three
(λf.λx.λy.
if iszero y
then zero
else add x (f x (pred y)) (λs.(mult1 (s s)) λs.(mult1 (s s)))  three (pred two))


====== OPERATION - EXPONENTS ======
rec power x y
if iszero y
then one
else mult x (power x (pred y))

====== OPERATION - SUBTRACTION ======
rec sub x y
if iszero y
then x
else sub (pred x) (pred y)

====== OPERATION - COMPARISON ======
absolute difference
def abs-diff x y = add (sub x y) (sub y x)
def equal x y = iszero (abs-diff x y)

|#

(define (nat-sub x y)
  (cond [(<= x 0) 0]
        [(<= y 0) x]
        [else (nat-sub (- x 1) (- y 1 ))])
  )


; =========================================
; EXERCISES


#|
4.1
The following function finds the sum of the numbers between n and zero:


def sum1 f n = 
if iszero n 
then zero 
else add n (f (pred n))

def sum = recursive sum1

Evaluate: sum three

answer:
sum three =>
recursive sum1 three =>

we know recursive f = λf.(λs.f(s s) λs.f(s s))
so substitute

λf.(λs.f(s s) λs.f(s s)) sum1 three =>
(λs.sum1(s s) λs.sum1(s s)) three =>
sum1 (λs.sum1(s s) λs.sum1(s s)) three =>

(λf.λn.
if iszero n 
then zero 
else add n (f (pred n)) (λs.sum1(s s) λs.sum1(s s)) three) =>

if iszero three
then zero 
else add three ((λs.sum1(s s) λs.sum1(s s)) (pred three)) =>

zero is not three, so run the else case =>

add three ((λs.sum1(s s) λs.sum1(s s)) (pred three)) =>
add three ((λs.sum1(s s) λs.sum1(s s)) two) =>

add three sum1 λs.sum1(s s) λs.sum1(s s) two =>

add three
(λf.λn.
if iszero n 
then zero 
else add n (f (pred n)) (λs.sum1(s s) λs.sum1(s s)) two) =>

add three
if iszero two
then zero 
else add two ((λs.sum1(s s) λs.sum1(s s)) (pred two)) =>

two is not zero so run else case
add three
add two ((λs.sum1(s s) λs.sum1(s s)) (pred two)) =>

add two ((λs.sum1(s s) λs.sum1(s s)) one) => ...
repeat until

add three add two add one zero =>
six

; ==============================

4.2
write a function that finds the rpdouct of numbers between n and one

def prod 1 f n = ...
def prod = recursive prod1

so that
prod n
in λ calc is equivalent to
n * n-1 * n-2 * ... * 1
in normal arithmetic (there is no escape from 'factorial' ...)
evaluate: prod three

answer:

|#
; lets start with a racket function first since its easier to translate
(define (prod n)
  (cond [(<= n 1) 1]
        [else (* n (prod (- n 1))) ])
  )
(prod 1)

#|
def prod1 f n
if (or (iszero n) (iszero (pred n)))
then one
else (mult n (f (pred n)))

def prod = recursive prod1

now evaluate prod three =>
recursive prod1 three =>

we know recursive f = λf.(λs.f(s s) λs.f(s s))
so substitute

λf.(λs.f(s s) λs.f(s s)) prod1 three =>
(λs.prod1(s s) λs.prod1(s s)) three =>

since we know prod1 definition, subsittude

λf.λn.
if (or (iszero n) (iszero (pred n)))
then one
else (mult n (f (pred n))) (λs.prod1(s s)  λs.prod1(s s)) three =>

if (or (iszero three) (iszero (pred three)))
then one
else (mult three (f (pred three))) =>

since three is notzero and three is not one the else case runs
(mult three (f (pred three))) =>
(mult three (f two)) =>
(mult three ((λs.prod1(s s)  λs.prod1(s s)) two)) =>

focus on inside
((λs.prod1(s s)  λs.prod1(s s)) two) =>
prod1 (λs.prod1(s s) λs.prod1(s s)) two =>

λf.λn.
if (or (iszero n) (iszero (pred n)))
then one
else (mult n (f (pred n))) (λs.prod1(s s)  λs.prod1(s s)) two =>

if (or (iszero two) (iszero (pred two)))
then one
else (mult two ((λs.prod1(s s)  λs.prod1(s s)) one) =>

since two is not zero or one, run else case
(mult two ((λs.prod1(s s)  λs.prod1(s s)) one)

repeat the step again until we reach n =1
backing up we accumulate by then (mult three (mult two one)) =>

mult three one =>
three

...

; ==============================

4.3 write a function which finds the sum of applying a function fun to the numbers between n and zero
def fun_sum1 f n = ...
def fun_sum = recursive fun_sum1

for example, given the squaring function:
def sq x = mult x x

then fun_sum sq three
in λcalc is equivalent to 3^2 + 2^2 + 1^2 + 0^2
in arithmetic.

evaluate: fun_sum double three
given doubling function def double x = add x x

answer:
lets try to approach this in racket function first since its simpler


|#
(define (fun_sum1 f n)
  (cond [(zero? n) 0] ;since the range is between n and zero, stop when n is zero
        [else (+ (f n) (fun_sum1 f (- n 1)) ) ])
  )
(fun_sum1 sqr 3) ; should return 3^2 + 2^2 + 1^2 + 0^2 = 9+4+1+0 = 14

#|
now back to the λcalc definition

def fun_sum1 f fun n
if iszero? n
then zero
else (add (fun n) (f fun (pred n)))

def fun_sum = recursive fun_sum1

now for evaluation
fun_sum double three =>
recursive fun_sum1 double three =>

we know recursive f = λf.(λs.f(s s) λs.f(s s))
so substitute

λf.(λs.f(s s) λs.f(s s)) fun_sum1 double three =>
(λs.fun_sum1(s s) λs.fun_sum1(s s)) double three =>
fun_sum1 (λs.fun_sum1(s s) λs.fun_sum1(s s)) double three =>

we know the definition of sum1, substitute

(λf.λfun.λn.
if iszero? n
then zero
else (add (fun n) (f fun (pred n))) (λs.fun_sum1(s s) λs.fun_sum1(s s)) double three) =>

if iszero? three
then zero
else (add (double three) (f double (pred three))) =>

since three is not zero, we run the else cond

else (add six ((λs.fun_sum1(s s) λs.fun_sum1(s s)) double (pred three))) =>

focus on inner
((λs.fun_sum1(s s) λs.fun_sum1(s s)) double (pred three)) =>
fun_sum1 (λs.fun_sum1(s s) λs.fun_sum1(s s))  double (pred three) =>

substitute fun_sum1 back again
(λf.λfun.λn.
if iszero? n
then zero
else (add (fun n) (f fun (pred n))) (λs.fun_sum1(s s) λs.fun_sum1(s s)) double two) =>

if iszero? two
then zero
else (add (double two) (f double (pred two))) =>

since two is not zero, run the else cond

else (add four ((λs.fun_sum1(s s) λs.fun_sum1(s s)) double one )) =>
focus on inner again,

((λs.fun_sum1(s s) λs.fun_sum1(s s)) double one ) =>
fun_sum1 (λs.fun_sum1(s s) λs.fun_sum1(s s)) double one =>
if iszero? one
then zero
else (add two (f double zero)) =>

so this proces repeats again until it reaches the base case where n = 0

(add six (add four (add two zero)))
(add six (add four two))
(add six six)
twelve


; ==============================
4.4 define a function to find the sum of applying a function fun to the numbers between n and zero
in the steps of s:

def fun_sum_step1 f fun n s = ...
def fun_sum_step = recursive fun_sum_step1

so for exampl
fun_sum_step sq six twi
in λcalc is equivalent to:
6^2 + 4^2 + 2^2 + 0^2 = 56 in normal arithmetic

evaluate:
a. fun_sum_step double five two
b. fun_sum_step double four two

answer:
lets try to define this in racket first since its simpler, assume its arleady recursive
no need to pass recursive driver for simplicity just ot get the basic logic
|#


(define (fun-sum-step1 f n s)
  ; if step is 0, return ??
  (cond [(<= n 0) 0]
        [else (+ (f n) (fun-sum-step1 f (- n s) s)) ])
  )
(fun-sum-step1 sqr 5 2) ;should reutrn 56


(define (double n) (+ n n))
(fun-sum-step1 double 5 2)
#|
now to translate back to λcalc

def fun-sum-step1 f fun n s
if iszero? n
then zero
else (add (fun n) (f fun (subtract n s) s))

def fun-sum-step recursive fun-sum-step1

now to test the 1st evaluation
a. fun_sum_step double five two =>
recursive fun-sum-step1 double five two =>

we know recursive f = λf.(λs.f(s s) λs.f(s s)), substtute
λf.(λs.f(s s) λs.f(s s)) fun-sum-step1 double five two =>
(λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double five two =>
fun-sum-step1 (λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double five two =>

substitute deifniton for sun-sum-step1

(λf.λfun.λn.λs.
if iszero? n
then zero
else (add (fun n) (f fun (subtract n s) s)) double five two) =>

if iszero? five
then zero
else (add (double five) (f double (subtract five two) two)) =>

since five is not zeor, run the else cond
(add ten ((λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double three two)) =>

zoom in on the recursive function
((λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double three two) =>
fun-sum-step1 (λs.fun-sum-step1(s s) λs.fun-sum-step1(s s))  double three two =>

substitute definition for fun-sum-step1
with n = three

if iszero? three
then zero
else (add (double three) (f double (subtract three two) two)) =>

since three is not zero , run the else case
(add six (f double one two)) =>
(add six ((λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double one two)) =>

zoom in again on the recursive function
(λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double one two =>
fun-sum-step1 (λs.fun-sum-step1(s s) λs.fun-sum-step1(s s)) double one two =>

repeat, substitute fun-sum-step1 definition
with n=one
if iszero? one
then zero
else (add (double one) (f double (subtract one two) two)) =>
(add two (f double zero two)) =>

here f double zero two since n is zero, it returns 0

so going back up we have
(add ten (add six (add two zero))) =>
(add ten (add six two)) =>
(add ten eight) =>
eighteen

end of a

b. fun_sum_step double four two
this one in terms of process its the same of a, so ill just show the ideas here inteas
of evaluating everything

ist call =>
n = 4 -> 4 is not zero, recurse with new n = 2

2nd call ->
n = 2 -> 2 is not zero, recurse with new n = 0

3rd call ->
n is zero, stop and evaluate back

so we have something like this
(add eight (add four zero))
(add eight four)
twelve


; ==============================
4.5 define functions to test wether or not a number is less than or less than equal to another number

def less x y = ...

def less_or_equal x y = ...

evaluate:
a. less three two
b. less two three
c. less two two
d. less_or_equal three two
e. less_or_equal two three
f. less_or_equal two two

lets start this with a racket function since its simpler
|#

(define (less x y)
  (cond [(and (zero? x) (zero? y)) #f]
        [(zero? x) #t]
        [(zero? y) #f]
        [else (less (- x 1) (- y 1)) ])
  )

(define (less-or-equal x y)
  (cond [(zero? x) #t]
        [(zero? y) #f]
        [else (less-or-equal (- x 1) (- y 1)) ])
  )

#|
nwo back to λcalc definition

def less_or-equal x y = iszero? (subtract x y)
def less x y = iszero? (subtract (succ x) y)

answer:
a. less three two = iszero? (subtract four two) = false
b. less two three = iszero? (subtract three three) = true
c. less two two = iszero? (subtract three two) = false
d. less-or-equal three two = iszero? (subtract three two) = false
e. less-or-equal two three = iszero? (subtract two three) = true
f. less-or-equal two two = iszero? (subtract two two) = true


|#

; ==============================
#|
define a function to find the remainder on dividing one number by another: 
def mod x y = 
Evaluate: 
(a) mod three two 
(b) mod two three 
(c) mod three zero

answer:
ok so we know mod is the remainder when we divide a number by a divisor
n = dq + r if i remember correctly

lets try to define this in racket first for simplicity

|#

(define (mod x y)
  (cond [(< x y) x]
        [else (mod (- x y) y)])
  )
(mod 13 5) ;should return 3
(mod 5 5) ;should reutrn 0
(mod 5 13) ; should reutrn 5

#|
now translate  to lambda calculus

def mod1 f x y
if iszero? y
then zero
else if less x y
     then x
     else (f (subtract x y) y)

def mod = recursive mod1

now evaluation
a. mod three two =>
recursive mod1 three two =>

since we know recursive f = λf.(λs.f(s s) λs.f(s s))
λf.(λs.f(s s) λs.f(s s)) mod1 three two =>
(λs.mod1(s s) λs.mod1(s s)) three two =>
mod1 (λs.mod1(s s) λs.mod1(s s))  three two =>

by the definition of mod1 we can substitute

λf.λx.λy
if iszero? y
then zero
else if less x y
     then x
     else (f (subtract x y) y) (λs.mod1(s s) λs.mod1(s s))  three two =>

if iszero? two
then zero
else if less three two
     then three
     else (f (subtract three two) two)  =>

since two is not zero, and three is not less than two continue on the else
((λs.mod1(s s) λs.mod1(s s)) one two) =>
... => 
x is less than y here, return 1

-----

b. mod two three =>
recursive mod1 two three =>
since we know recursive f = λf.(λs.f(s s) λs.f(s s))
λf.(λs.f(s s) λs.f(s s)) mod1 two three =>
(λs.mod1(s s) λs.mod1(s s)) two three =>
mod1 (λs.mod1(s s) λs.mod1(s s)) two three  =>

by the definition of mod1 we can substitute
...

λf.λx.λy
if iszero? y
then zero
else if less x y
     then x
     else (f (subtract x y) y) (λs.mod1(s s) λs.mod1(s s))  two three =>

if iszero? three
then zero
else if less two three
     then two
     else (f (subtract two three) two)  =>

since three is not zero it goes to the 1st else.
then on this one it checks if two is less than three, which is true.
so rturn two.

c. mod three zero
since y is zero, it passes the irst checkf or iszero?y -> reutrn zero

|#