#lang racket

; identity:: λf.f
(define identity (λ(f) f))

; apply:: λf.λg.(f g)
(define apply (λ(f)
                (λ (g)
                  (f g))))

; select-first:: λf.λs.f
(define select-first (λ (f) (λ (s) f )))

; select-second:: λf.λs.s
(define select-second (λ (f) (λ (s) s )))

; self-apply:: λs(s s)
(define self-apply (λ (s) (s s) ))

; make-pair: λfirst.λsecond.λfunc((func first) second)
(define make-pair (λ (first) (lambda (second) (lambda (func) ((func first) second) ) ) ))


;((select-first 122) 158)
;(select-second 122)
;(((make-pair 111) 123) select-first)


#|

Exercises
Analyse each of the following A expressions to clarify its structure. If 
the expression is a function, identify the bound variable and the 
body expression, and then analyse the body expression. If the 
expression is an application, identify the function and argument 
expressions, and then analyse the function and argument 
expressions:

ref: functions: λx.e
app: (E1 E2)

2.1
identify: function or application?
breakdown: bound variable & body expression


a. λa.(a λb.(b a))
b. λx.λy.λz.((z x) (z y))
c. (λf.λg(λh.(g h) f) λp.λq.p)
d. λfee.λfi.λfo.λfum.(fum (fo (fi fee)))
e. (λp.(λq.p λx(x p)) λi.λj.(j i))

answer:
a. λa.(a λb.(b a))
function or application? this is a function that takes a as arg
bound variable: a
body expression: (a λb.(b a))

(a λb.(b a))
type: application
function: a
argument: λb.(b a)

λb.(b a)
type: function
bound variable: b
body: (b a)

(b a)
type: application
function: b
arg: a

end

b.λx.λy.λz.((z x) (z y))
type: function
bound variable: x
body: λy.λz.((z x) (z y))

λy.λz.((z x) (z y))
type: function
bound variable: y
body: λz.((z x) (z y))

λz.((z x) (z y))
type: function
bound variable: z
body: ((z x) (z y))

((z x) (z y))
type: application
function: (z x)
argument: (z y)

(z x)
type: application
function: z
arg: x

(z y)
type: application
function: z
arg: y

end

==========================================

c.(λf.λg(λh.(g h) f) λp.λq.p)
type: application
function: λf.λg(λh.(g h) f)
arg: λp.λq.p

---

λf.λg(λh.(g h) f)
type: function
bound variable: f
body: λg(λh.(g h) f)

λg(λh.(g h) f)
type: function
bound var: g
body: (λh.(g h) f)

(λh.(g h) f)
type: application
function: λh.(g h)
argument: f

λh.(g h)
type: function
bound var: h
body: (g h)

(g h)
type: application
function: g
arg: h

done

--

λp.λq.p
type: function
bound variable: p
body: λq.p

λq.p
type: function
bound variable: q
body: p

done

==========================================

d. λfee.λfi.λfo.λfum.(fum (fo (fi fee)))
type: function
bound variable: fee
body: λfi.λfo.λfum.(fum (fo (fi fee)))

λfi.λfo.λfum.(fum (fo (fi fee)))
type: function
bound var: fi
body: λfo.λfum.(fum (fo (fi fee)))

λfo.λfum.(fum (fo (fi fee)))
type: Function
bound var: fo
body: λfum.(fum (fo (fi fee)))

λfum.(fum (fo (fi fee)))
type: function
bound var: fum
body: (fum (fo (fi fee)))

(fum (fo (fi fee)))
type: application
function: fum
arg: (fo (fi fee))

(fo (fi fee))
type: application
function: fo
arg: (fi fee)

(fi fee)
type: application
funcion: fi
arg: fee

end

==========================================

e. (λp.(λq.p λx.(x p)) λi.λj.(j i))
type: application
function: λp.(λq.p λx.(x p))
argument: λi.λj.(j i)

-----

λp.(λq.p λx.(x p))
type: function
bound var: p
body: (λq.p λx.(x p))

(λq.p λx.(x p))
type: application
function: λq.p
argument: λx.(x p)

λq.p
type: function
bound var: q
body: p

λx.(x p)
type: function
bound var: x
body: (x p)

(x p)
type: application
function: x
arg: p

end

-----

λi.λj.(j i)
type: function
bound var: i
body: λj.(j i)

 λj.(j i)
type: function
bound var: j
body: (j i)

(j i)
type: application
function: j
arg: i

end

===========================================


2.2 evaluate the following λexprs
a. ((λx.λy.(y x) λp.λq.p) λi.i)
b. (((λx.λy.λz.((x y) z) λf.λa.(f a)) λi.i) λj.j)
c. (λh.((λa.λf.(f a) h) h) λf.(f f)) 
d. ((λp.λq.(p q) (λx.x λa.λb.a)) λk.k)
e. (((λf.λg.λx.(f(g x)) λs.(s s)) λa.λb.b) λx.λy.x) 

answer:
a. 
((λx.λy.(y x) λp.λq.p) λi.i) =>
(λy.(y λp.λq.p) λi.i) =>
(λi.i λp.λq.p) =>
λp.λq.p

end

b. ( ( (λx.λy.λz.((x y)z) λf.λa.(f a)) λi.i ) λj.j)
innermost
(λx.λy.λz.((x y)z) λf.λa.(f a)) =>
λy.λz.((λf.λa.(f a) y)z) =>
λy.λz.(λa.(y a) z) =>
λy.λz.(y z)

back up
( ( λy.λz.(y z) λi.i ) λj.j) =>

inner
λz.(λi.i z) =>
λz.z

back up
(λz.z λj.j) =>
λj.j

end

c. (λh.((λa.λf.(f a) h) h) λf.(f f))
inner
(λa.λf.(f a) h) =>
λf.(f h)

((λa.λf.(f a) h) h) =>
(λf.(f h) h) =>
(h h)

(λh.(h h) λf.(f f)) =>
(λf.(f f) λf.(f f)) =>
(λf.(f f) λf.(f f)) => ...

therefore it has no normal form

d. ((λp.λq.(p q) (λx.x λa.λb.a)) λk.k)
inner
(λp.λq.(p q) (λx.x λa.λb.a)) =>

arg
(λx.x λa.λb.a) =>
λa.λb.a

(λp.λq.(p q) (λx.x λa.λb.a)) =>
(λp.λq.(p q) λa.λb.a) =>
λq.(λa.λb.a q) =>
λq.λb.q

back up
(λq.λb.q λk.k) =>
λb.λk.k

e. ( ( (λf.λg.λx.(f(g x)) λs.(s s)) λa.λb.b) λx.λy.x)

inner application
(λf.λg.λx.(f(g x)) λs.(s s)) =>
λg.λx.(λs.(s s) (g x)) =>
λg.λx.((g x) (g x))

( (λf.λg.λx.(f(g x)) λs.(s s)) λa.λb.b) =>
(λg.λx.((g x) (g x)) λa.λb.b) =>
λx.((λa.λb.b x) (λa.λb.b x)) =>
λx.(λb.b λb.b) =>
λx.λb.b

(λx.λb.b λx.λy.x) =>
λb.b
b

end

===========================================


2.3
For each of the following pairs, show that function (i) is equivalent 
to the function resulting from expression (ii) by applying both to 
arbitrary arguments:

a.
1. identity
2. (apply (apply identity))

b.
1. apply
2. λx.λy.(((make-pair x) y) identity) 

c.
1. identity
2. (self-apply (self-apply select-second))

answer:

refrence
apply:: λf.λg.(f g)
identity:: λf.f
make-pair:: λf.λs.λfunc((func f) s)
self-apply:: λs(s s)
select-first:: λf.λs.f
select-second:: λf.λs.s


let arg = z

a.
1. (identity z) => (λf.f z) => z
2. (apply (apply identity)) =>
((apply (apply identity)) z)

inner part
(apply identity) =>
(λf.λg.(f g)  λf.f) =>
λg.(λf.f g)=>
λg.g

((apply λg.g) z) =>
inner part
(λf.λg.(f g) λg.g) =>
λg.(λg.g g) =>
λg.g

back up
((apply λg.g) z) =>
(λg.g z) =>
z

therefore 1 and 2 is equal

-----

b.
1. (apply z) =>
(λf.λg.(f g) z) =>
λg.(z g)


2. λx.λy.(((make-pair x) y) identity)
(λx.λy.(((make-pair x) y) identity) z) =>

inner part
make-pair:: λf.λs.λfunc((func f) s)
((make-pair x) y) ->
( (λf.λs.λfunc((func f)s) x) y) ->
(λs.λfunc.((func x)s) y) ->
λfunc.((func x)y)

back up
(((make-pair x) y) identity) z) =>
(λfunc.((func x)y) identity) =>
((identity x) y) =>

(λx.λy.((identity x) y) z) =>
λy.((identity z) y) =>
λy.((λf.f z) y) =>
λy.(z y)

therefore 1 and 2 is equal

-----

c.
1. identity
(identity z) =>
(λf.f z) =>
z

2. (self-apply (self-apply select-second))
((self-apply (self-apply select-second)) z) =>

inner part
(self-apply select-second)
(λs(s s) λf.λs.s) =>
(λf.λs.s  λf.λs.s) =>
λs.s

back up
((self-apply λs.s) z) =>

inner part
(λs(s s) λs.s) =>
(λs.s λs.s) =>
λs.s

((self-apply λs.s) z) =>
(λs.s z) =>
z

end
therefore 1 and 2 is equal

===========================================

2.4
Define a function: 
def make_triplet = ...
which is like make_pair but constructs a triplet from a sequence of 
three arguments so that any one of the arguments may be selected 
by the subsequent application of a triplet to a selector function. 
Define selector functions: 
def triplet_first = ...
def tripleLsecond = ...
def triple_third = ...
which will select the first, second or third item from a triplet 
respectively.

Show that:
make-triplet <item1> <item2> <item3>
triplet_first => ... => <item1>
make-triplet <item1> <item2> <item3>
triplet_second => ... => <item2>
make-triplet <item1> <item2> <item3>
triplet_third => ... => <item3>

for the arbitrary argumjent <item1> <item2> <item3>

answer:

ok so we need to find a way make a triplet, and we know make-pair does something like this

make-pair:: λf.λs.λfunc((func f) s)
this takes 3 args, first item, 2nd item, and last is the function

so in make triplet we need 3 arg and apply the function last
make-triplet:: λf.λs.λt.λfunc.(((func f) s) t)

now for the selectors
we know select first does something like λf.λs.f
and select second does something like λf.λs.s but here we accept 3 args since its a triplet

triplet-first:: λf.λs.λt.f
tripelt-second:: λf.λs.λt.s
triplet-third:: λf.λs.λt.t

now lets test it
triplet-first
( (((make-triplet item1) item2) item3) triplet-first) =>

inner function
(((make-triplet item1) item2) item3) =>
(((λf.λs.λt.λfunc.(((func f) s) t) item1) item2) item3) =>
... =>
(λfunc.(((func item1) item2) item3)  λf.λs.λt.f) =>
(((λf.λs.λt.f item1) item2) item3) =>


(λf.λs.λt.f item1) =>
λs.λt.item1

((λs.λt.item1 item2) item3)
(λs.λt.item1 item2) =>
λt.item1 =>

(λt.item1 item3)
(λt.item1 item3) =>
item1

-------

triplet-second
( (((make-triplet item1) item2) item3) triplet-second)

( (((λf.λs.λt.λfunc.(((func f) s) t) item1) item2) item3) λf.λs.λt.s) =>

inner function
(((λf.λs.λt.λfunc.(((func f) s) t) item1) item2) item3) =>
((λs.λt.λfunc.(((func item1) s) t) item2) item3) => ... =>
(λfunc.(((func item1) item2) item3) λf.λs.λt.s) =>
(((λf.λs.λt.s item1) item2) item3) =>

((λs.λt.s item2) item3) =>
(λt.item2 item3) =>
item2

end


------


triplet-third
( (((make-triplet item1) item2) item3) triplet-third)

inner function
(((λf.λs.λt.λfunc.(((func f) s) t) item1) item2) item3) =>
((λs.λt.λfunc.(((func item1) s) t) item2) item3) => ... =>
(λfunc.(((func item1) item2) item3) λf.λs.λt.t) =>
(((λf.λs.λt.t item1) item2) item3) =>
((λs.λt.t item2) item3) =>
(λt.t item3) =>
item3

end


question: why is it in make-pair and make-triplet etc,  we need to take function as the last parameter, and why do we
need to apply it to the first arg?? eg

in make pair λf.λs.λfunc((func f) s) <- why do we need the last λfunc? and why do we apply the func to the 1st arg?

so we take the func last because we wanna define the pair first
so we build the pair eg ((make-pair 10) 20)
then once the pair is built, we need the instructino on what to do with these 10 and 20

func is applied to the 1st arg coz im lambda calculus funcitosn always take 1 arg
our function/key want to interact with all of the args previously given (eg the 2 item)
so it has to travel 1 by 1


but the ordering does it matter? if func is aplied to last one then the first?

===========================================

2.5 analyze each of the following λ exprs to identify its
free and bound variables, and those in its subexprsession

a. λx.λy.(λx.y λy.x)
b. λx.(x (λy.(λx.x y) x)) 
c. λa.(λb.a λb.(λa.a b))
d. (λfree.bound λbound.(λfree.free bound)) 
e. λp.λq (λr.(p (λq.(λp.(r q)))) (q p)) 

answer:
a. λx.λy.(λx.y λy.x)
bound variables
outer function λx.λy.(λx.y λy.x)
bound variable: x
body: λy.(λx.y λy.x)

λy.(λx.y λy.x)
bound variable: y
body: (λx.y λy.x)

application (λx.y λy.x) =>
func: λx.y
arg: λy.x
bound variable: x
free variable: y
body: y

-----

b. 
λx.(x (λy.(λx.x y) x))
there are 2 x variables
outer one:
λx.(x (λy.(λx.x y) x))
bound variable: x
body: (x (λy.(λx.x y) x)) which is an application

then the inner part
(λy.(λx.x y) x)
(λx.x y)the x here is bound to λx

then the x argument here
(λy.(λx.x y) x) the x is bound to the outer one

-----

c.
(λfree.bound λbound.(λfree.free bound))
here we have an application
with thefunciton λfree.bound
and argument λbound.(λfree.free bound)

here we have 2 variables named "free", the inner one ad the outer one

the outer variable named bound is free (body of free/ λfree.bound )

then the application argument
λbound.(λfree.free bound)
here the bound variable inside the body is bound to bound.
λfree.free and the free here is bound to free

-----

e. λp.λq.(λr.( p(λq.(λp.(r q)))) (q p) )

we have an application (λr.(p (λq.(λp.(r q)))) (q p))
with the function λr.(p (λq.(λp.(r q))))
and argument (q p)


the q in (q p) binds to outermost λq
the p in (q p) binds to outermost λp

===========================================

2.6
use alpha conversion to ensure unique names in the exprs in exercise 2.5 above

answer:
a. λx.λy.(λx.y λy.x)
= λx.λy.(λa.y λb.x)

b. λx.(x (λy.(λx.x y) x))
= λx.(x (λa.(λb.b a) x) )

c. λa.(λb.a λb.(λa.a b))
= λa.(λb.a λc.(λd.d c))

d. (λfree.bound λbound.(λfree.free bound))
= (λb.a λa.(λb.b a))
= (λc.d λa.(λb.b a))

e. λp.λq.(λr.(p (λq.(λp.(r q)))) (q p))
= λp.λq. (λr. (p (λx.(λz.(r x)))) (q p))

|#
