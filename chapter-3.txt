Data Structures

Contiguous vs Linked

Contiguous
Array -> each elmelent can be located by its index/house number
A street full of houses

+ instant time access/lookups
+ space efficent
+ memory locality
+ great for iteratiog

- cant do n+1 /more than n/fixed memory size
- resizing sucks

Linked
List, trees
houses that points to other houses,
to get address #500, you'd need to find house #1, hosue #2, etc

+ easy insertion/deletion
+ flexible memory allocation
- slow lookup
- not cache friendly

=================================

Pointers
connection that hold the piece of linked structures together, like a chain
represnts the address of a location



=================================

Stacks and queues

you put things in, you take things out later
the difference between stacks and queues is the rule that you decide
what to take out next.

Stack (LIFO)
cafetaria trays - only cares about the most recent item
- Undo functionality
- function call stack
- browser back button

Queue (FIFO)
movie ticket queue/orderly coffee shop
fair ordering
- ticket purchasing app
- print document
- BFS 


========================================

Dictionaries

is a storage system dhat does 3 things:
- insert
- delete
- search

key-value structure
keys are unique
hash table is a dicitionary

stop and think: comparing dictionary implementations

 Problem: What are the asymptotic worst-case running times for each of the seven
 fundamental dictionary operations (search, insert, delete, successor, predecessor,
 minimum, and maximum) when the data structure is implemented as:

 • An unsorted array.
 • Asorted array.

answer:
unsorted  array
search: you have to check the item 1 by 1 if you wanna earch for something , so worst case is O(n)
insert: since this is unserted O(1)
delete: finding the element is O(n) then shift 
successor: need to find the entire array, O(n)
predeccor: same as successor, O(n)
min: need to check all elements, O(n)
max: same as min, O(n)

 
sorted
search: we can use binary search, so O(log nn)
insert: the item inserted needs to be sorted so need to check each element 1 by 1 O(n)
delete: same as insert, check element 1 by 1 then shift O(n)
successor: o1
predeccor: o1
min: O(1) since its sorted, just get the head
max: O(1) same as min

read/write
read -> sorted
write -> unsorted


comparing dictionary implementations
singly linked unsorted list
search: since this is unsorted linked list it needs to check the whole item , so O(n)
insert: O(1), just insert it to the head
delete: find the item -> delete -> reassign pointer (update x predecessor so it points to x successor), O(n)
successor: find each item 1 by one, O(n)
predeccor: same as successor, O(n)
min: O(n)
max: O(n)

double  linked unsorted list
search: on
insert: o1
delete: o1
successor: on
predeccor: on
min: o1
max: o1

sorted linked list
search: stilll On
insert: O(n) since we need to check 1by1
delete: same as insert, O(n)
successor: On
predeccor: On
min: O1
max: O(n)

doubly linked sorted list
search: still O(n), need to check 1 by 1
insert: O(n), same as search
delete: O(n)
successor: since its sorted it should be O(1) right?
predeccor: O(1)
min: o1
max: o1 since we have tail pointer?


=====================

BST
search rule: if key is smaller than target, go to the left subtree
if the key is bigger than the target, go to the right subree

how it works
start at the root
at each node, make one comparison and move down one level (1 step)
repeat the process until we find the key or hit the end of the branch

degenerate tree - unbalanced

; A BinaryTree (BT) is one of:
; 1. '() ; The empty tree
; 2. (make-node number BT BT) ; A node with a 

-----

Searching
search(bt, target)
value = value(bt) ;get bt's root value
if value = null ; no more children to check, not found
    return null
if value = target ; target found
    return value
if value < target
    return search(bt_left, target) ;recurse to the left
    else return search(bt_right, target) ;recurse to the right
    
-----

Min-Max

-----

In-order traversal
list every item in order

-----

Insertion

-----

Deletion
the difficulty is in reassignment,
you can't just delete a node since it leaves a empty space

deleting 0 child - just delete leaf
deleting 1 child - pass to grandchild
deleting 2 child

=================

BST good and bad

Problem: You are given the task of reading n numbers and then printing them
out in sorted order. Suppose you have access to a balanced dictionary data struc
ture, which supports the operations search, insert, delete, minimum, maximum,
successor, and predecessor each in O(logn) time.
1. How can you sort in O(nlogn) time using only insert and in-order traversal?
answer:
so the task is reading, then writing them in sorted order
read -> print (in sorted order)

1. take all n inputs and put them in the dictionary
single number takes o(log n) * n = n log n

traversal = takes n time
so n log n + n > n log n dominates

2. How can you sort in O(nlogn) time using only minimum, successor, and
insert?
build structure
insert all items -> n . log n = n log n
cost for minimum = log n
cost of n -1 uscesor = (n-1) log n = n log n

total = n log n + n log n = n log n

3. How can you sort in O(nlogn) time using only minimum, insert, delete,
search?

build structure
insert all items -> n . log n = n log n

find minimum -> log n
print it -> 1
delete it -> log n
repeat

so one cycle is log n
we wana aply it to all n items
so n . log n = n log n

======================

Priority Queue
aka sort by importance

3 things:
Insert
find min, find max
delete

hospital emergency

===========================
Stop and think:
 Problem: What is the worst-case time complexity of the three basic priorityqueue
 operations (insert, find-minimum, and delete-minimum)
when the basic data structure is

• An unsorted array.
• Asorted array.
• Abalanced binary search tree.

answer:
unsorted array:
- insert: since its unsorted you can just insert at the beginning of an array? so O(1)?
i'm not sure if its the same with priority queue

- find min: check eaci item 1 by 1, O(n)

- delete min: check each item 1 by 1 and delete it so O(n)

sorted array:
- insert: O(n) since this is sorted
- find min: O(1), just the check the first item/heado f the array
- delete min: O(n), delete the first and shift the remaining array

balanced BST:
since bst is sorted
- insert: find (n log n) and insert to correct leaf
- find min: log n
- delete min: log n


=========================

Hash tbales
o1 lookup
turning search -> arithmetic
using modulo base 10 operators
different key uses different numbers

1. Calculate a number from your key (fast)
2. Use that number as an array index (instant)

Collusion
Chaining vs open addressing